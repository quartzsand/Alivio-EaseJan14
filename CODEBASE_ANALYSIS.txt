=== ALIVIO'S EASEL CODEBASE ANALYSIS ===

=== PACKAGE.JSON ===
{
  "name": "my-app",
  "main": "client/index.js",
  "version": "1.0.0",
  "scripts": {
    "start": "npm run dev",
    "dev": "concurrently -k \"npm run server:dev\" \"npm run expo:dev\"",
    "expo:dev": "CI=1 EXPO_NO_TELEMETRY=1 npx expo start --tunnel --clear --port 8081",
    "expo:local": "CI=1 EXPO_NO_TELEMETRY=1 npx expo start --localhost --clear --port 8081",
    "dev:mobile": "CI=1 EXPO_NO_TELEMETRY=1 npx expo start --tunnel --clear --port 8081",
    "server:dev": "PORT=5000 NODE_ENV=development tsx server/index.ts",
    "server:build": "esbuild server/index.ts --platform=node --packages=external --bundle --format=cjs --outfile=server_dist/index.cjs",
    "server:prod": "npm run server:build && PORT=5000 NODE_ENV=production node server_dist/index.cjs",
    "db:push": "drizzle-kit push",
    "lint": "npx expo lint",
    "lint:fix": "npx expo lint --fix",
    "check:types": "tsc --noEmit",
    "check:format": "prettier --check \"**/*.{js,ts,tsx,css,json}\"",
    "format": "prettier --write \"**/*.{js,ts,tsx,css,json}\""
  },
  "dependencies": {
    "@expo-google-fonts/nunito": "^0.4.2",
    "@expo/ngrok": "^4.1.3",
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/slider": "5.0.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.15",
    "@react-navigation/native-stack": "^7.1.7",
    "@replit/vite-plugin-cartographer": "^0.4.4",
    "@replit/vite-plugin-dev-banner": "^0.1.1",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.4",
    "@tailwindcss/typography": "^0.5.19",
    "@tanstack/react-query": "^5.90.17",
    "@vitejs/plugin-react": "^5.1.2",
    "babel-plugin-module-resolver": "^5.0.2",
    "drizzle-orm": "^0.38.3",
    "eslint": "^9.39.2",
    "eslint-config-expo": "^10.0.0",
    "eslint-plugin-prettier": "^5.5.5",
    "expo": "^54.0.31",
    "expo-av": "~16.0.8",
    "expo-blur": "~15.0.8",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.10",
    "expo-haptics": "~15.0.8",
    "expo-keep-awake": "~15.0.8",
    "expo-linear-gradient": "~15.0.8",
    "expo-linking": "~8.0.11",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-system-ui": "~6.0.9",
    "expo-web-browser": "~15.0.10",
    "express": "^4.18.2",
    "postgres": "^3.4.5",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-native": "^0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-keyboard-controller": "^1.18.5",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "0.5.1",
    "tailwindcss": "^4.1.18",
    "tailwindcss-animate": "^1.0.7",
    "vite": "^7.3.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/express": "^4.17.21",
    "@types/react": "^19.1.10",
    "@types/react-test-renderer": "^18.3.0",
    "concurrently": "^9.1.2",
    "drizzle-kit": "^0.30.2",
    "esbuild": "^0.24.2",
    "prettier": "^3.4.2",
    "tsx": "^4.19.2",
    "typescript": "^5.9.2"
  },
  "private": true
}

=== APP.JSON ===
{
  "expo": {
    "name": "Alivio's Easel",
    "slug": "alivio-ease",
    "version": "1.0.0",
    "platforms": [
      "ios",
      "android",
      "web"
    ],
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#005EB8"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.alivio.ease",
      "infoPlist": {
        "UIBackgroundModes": [
          "audio"
        ],
        "NSUserTrackingUsageDescription": "We do not track you. This permission is not used."
      }
    },
    "android": {
      "package": "com.alivio.ease",
      "permissions": [
        "VIBRATE",
        "WAKE_LOCK",
        "POST_NOTIFICATIONS"
      ]
    },
    "extra": {
      "disclaimer": "This app is not a medical device. For wellness purposes only."
    },
    "plugins": [
      "expo-font",
      "expo-web-browser"
    ]
  }
}

=== PROBLEMATIC FILES ===
-e 
========== FILE: ./client/screens/ProfileScreen.tsx ==========
import React, { useState } from "react";
import { View, StyleSheet, Pressable, Image, TextInput, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useBottomTabBarHeight } from "@react-navigation/bottom-tabs";
import { Feather } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import { KeyboardAwareScrollViewCompat } from "@/components/KeyboardAwareScrollViewCompat";
import { ThemedText } from "@/components/ThemedText";
import { Card } from "@/components/Card";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";

import avatarBlue from "../../assets/images/avatar-dragonfly-blue.png";
import avatarGreen from "../../assets/images/avatar-dragonfly-green.png";
import avatarPurple from "../../assets/images/avatar-dragonfly-purple.png";
import avatarPink from "../../assets/images/avatar-dragonfly-pink.png";

const AVATARS = [
  { id: "blue", source: avatarBlue },
  { id: "green", source: avatarGreen },
  { id: "purple", source: avatarPurple },
  { id: "pink", source: avatarPink },
];

export default function ProfileScreen() {
  const insets = useSafeAreaInsets();
  const tabBarHeight = useBottomTabBarHeight();
  const { preferences, sessions, onboarding, updatePreferences } = useApp();
  const [editingName, setEditingName] = useState(false);
  const [name, setName] = useState(preferences.displayName);

  const currentAvatar = AVATARS.find((a) => a.id === preferences.avatarId) || AVATARS[0];

  const handleAvatarSelect = async (avatarId: string) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    await updatePreferences({ avatarId });
  };

  const handleSaveName = async () => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    await updatePreferences({ displayName: name || "Friend" });
    setEditingName(false);
  };

  const isMinor = onboarding.age !== null && onboarding.age < 18;

  return (
    <KeyboardAwareScrollViewCompat
      style={styles.container}
      contentContainerStyle={[
        styles.scrollContent,
        {
          paddingTop: insets.top + Spacing["3xl"],
          paddingBottom: tabBarHeight + Spacing["2xl"],
        },
      ]}
    >
      <ThemedText style={styles.title}>Profile</ThemedText>

      <View style={styles.avatarSection}>
        <Image source={currentAvatar.source} style={styles.avatarLarge} />
        
        <View style={styles.avatarOptions}>
          {AVATARS.map((avatar) => (
            <Pressable
              key={avatar.id}
              style={({ pressed }) => [
                styles.avatarOption,
                avatar.id === preferences.avatarId && styles.avatarOptionSelected,
                pressed && styles.avatarOptionPressed,
              ]}
              onPress={() => handleAvatarSelect(avatar.id)}
              testID={`avatar-${avatar.id}`}
            >
              <Image source={avatar.source} style={styles.avatarSmall} />
            </Pressable>
          ))}
        </View>
      </View>

      <Card style={styles.nameCard}>
        <View style={styles.nameRow}>
          <ThemedText style={styles.label}>Display Name</ThemedText>
          {editingName ? (
            <Pressable onPress={handleSaveName} testID="button-save-name">
              <Feather name="check" size={20} color={Colors.light.primary} />
            </Pressable>
          ) : (
            <Pressable onPress={() => setEditingName(true)} testID="button-edit-name">
              <Feather name="edit-2" size={20} color={Colors.light.textSecondary} />
            </Pressable>
          )}
        </View>
        {editingName ? (
          <TextInput
            style={styles.nameInput}
            value={name}
            onChangeText={setName}
            placeholder="Enter your name"
            placeholderTextColor={Colors.light.textSecondary}
            autoFocus
            onBlur={handleSaveName}
            testID="input-name"
          />
        ) : (
          <ThemedText style={styles.nameValue}>
            {preferences.displayName || "Friend"}
          </ThemedText>
        )}
      </Card>

      {isMinor ? (
        <View style={styles.badgeContainer}>
          <View style={styles.badge}>
            <Feather name="shield" size={16} color={Colors.light.primary} />
            <ThemedText style={styles.badgeText}>Guardian Verified</ThemedText>
          </View>
        </View>
      ) : null}

      <Card style={styles.statsCard}>
        <View style={styles.statRow}>
          <View style={styles.statIcon}>
            <Feather name="activity" size={24} color={Colors.light.accent} />
          </View>
          <View style={styles.statInfo}>
            <ThemedText style={styles.statValue}>{sessions.length}</ThemedText>
            <ThemedText style={styles.statLabel}>Total Sessions</ThemedText>
          </View>
        </View>
      </Card>
    </KeyboardAwareScrollViewCompat>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  scrollContent: {
    paddingHorizontal: Spacing.xl,
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
    marginBottom: Spacing["2xl"],
  },
  avatarSection: {
    alignItems: "center",
    marginBottom: Spacing["2xl"],
  },
  avatarLarge: {
    width: 120,
    height: 120,
    borderRadius: 60,
    marginBottom: Spacing.lg,
  },
  avatarOptions: {
    flexDirection: "row",
    gap: Spacing.md,
  },
  avatarOption: {
    width: 56,
    height: 56,
    borderRadius: 28,
    borderWidth: 2,
    borderColor: "transparent",
    overflow: "hidden",
  },
  avatarOptionSelected: {
    borderColor: Colors.light.primary,
  },
  avatarOptionPressed: {
    opacity: 0.7,
  },
  avatarSmall: {
    width: "100%",
    height: "100%",
  },
  nameCard: {
    marginBottom: Spacing.lg,
  },
  nameRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: Spacing.sm,
  },
  label: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
  },
  nameValue: {
    ...Typography.title,
    color: Colors.light.text,
  },
  nameInput: {
    ...Typography.title,
    color: Colors.light.text,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.primary,
    paddingBottom: Spacing.xs,
  },
  badgeContainer: {
    alignItems: "center",
    marginBottom: Spacing.lg,
  },
  badge: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.accent + "30",
    paddingVertical: Spacing.sm,
    paddingHorizontal: Spacing.lg,
    borderRadius: BorderRadius.full,
  },
  badgeText: {
    ...Typography.caption,
    color: Colors.light.primary,
    marginLeft: Spacing.sm,
  },
  statsCard: {
    marginBottom: Spacing.lg,
  },
  statRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  statIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: Colors.light.accent + "30",
    alignItems: "center",
    justifyContent: "center",
    marginRight: Spacing.lg,
  },
  statInfo: {
    flex: 1,
  },
  statValue: {
    ...Typography.headline,
    color: Colors.light.text,
  },
  statLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
  },
});
-e 
========== FILE: ./client/screens/HistoryScreen.tsx ==========
import React from "react";
import { View, StyleSheet, FlatList, Image } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useBottomTabBarHeight } from "@react-navigation/bottom-tabs";
import { Feather } from "@expo/vector-icons";
import { ThemedText } from "@/components/ThemedText";
import { Card } from "@/components/Card";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";
import { COMFORT_LABELS, HAPTIC_PATTERN_LABELS } from "@/types";
import type { SessionLog } from "@/types";

import emptyHistory from "../../assets/images/empty-history.png";

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
  
  if (diffDays === 0) {
    return `Today at ${date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
  } else if (diffDays === 1) {
    return `Yesterday at ${date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
  } else if (diffDays < 7) {
    return date.toLocaleDateString([], { weekday: "long" });
  }
  return date.toLocaleDateString([], { month: "short", day: "numeric" });
}

function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

function SessionCard({ session }: { session: SessionLog }) {
  return (
    <Card style={styles.sessionCard}>
      <View style={styles.sessionHeader}>
        <ThemedText style={styles.sessionDate}>{formatDate(session.date)}</ThemedText>
        <View style={styles.durationBadge}>
          <Feather name="clock" size={12} color={Colors.light.textSecondary} />
          <ThemedText style={styles.durationText}>{formatDuration(session.duration)}</ThemedText>
        </View>
      </View>
      
      <View style={styles.sessionDetails}>
        <View style={styles.detailRow}>
          <ThemedText style={styles.detailLabel}>Pattern</ThemedText>
          <ThemedText style={styles.detailValue}>
            {HAPTIC_PATTERN_LABELS[session.hapticPattern]}
          </ThemedText>
        </View>
        
        <View style={styles.detailRow}>
          <ThemedText style={styles.detailLabel}>Comfort</ThemedText>
          <View style={styles.comfortBadge}>
            <ThemedText style={styles.comfortText}>
              {COMFORT_LABELS[session.comfortRating]}
            </ThemedText>
          </View>
        </View>
      </View>
      
      {session.notes ? (
        <View style={styles.notesSection}>
          <ThemedText style={styles.notesLabel}>Notes</ThemedText>
          <ThemedText style={styles.notesText}>{session.notes}</ThemedText>
        </View>
      ) : null}
    </Card>
  );
}

function EmptyState() {
  return (
    <View style={styles.emptyState}>
      <Image source={emptyHistory} style={styles.emptyImage} resizeMode="contain" />
      <ThemedText style={styles.emptyTitle}>No sessions yet</ThemedText>
      <ThemedText style={styles.emptyText}>
        Start your first comfort session from the home screen
      </ThemedText>
    </View>
  );
}

export default function HistoryScreen() {
  const insets = useSafeAreaInsets();
  const tabBarHeight = useBottomTabBarHeight();
  const { sessions } = useApp();

  return (
    <View style={styles.container}>
      <FlatList
        data={sessions}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <SessionCard session={item} />}
        contentContainerStyle={[
          styles.listContent,
          {
            paddingTop: insets.top + Spacing["3xl"],
            paddingBottom: tabBarHeight + Spacing["2xl"],
          },
          sessions.length === 0 && styles.emptyContainer,
        ]}
        ListHeaderComponent={
          sessions.length > 0 ? (
            <ThemedText style={styles.title}>History</ThemedText>
          ) : null
        }
        ListEmptyComponent={<EmptyState />}
        showsVerticalScrollIndicator={false}
        scrollIndicatorInsets={{ bottom: insets.bottom }}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  listContent: {
    paddingHorizontal: Spacing.xl,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
    marginBottom: Spacing.lg,
  },
  sessionCard: {
    marginBottom: Spacing.md,
  },
  sessionHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: Spacing.md,
  },
  sessionDate: {
    ...Typography.button,
    color: Colors.light.text,
  },
  durationBadge: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.backgroundSecondary,
    paddingVertical: Spacing.xs,
    paddingHorizontal: Spacing.sm,
    borderRadius: BorderRadius.xs,
  },
  durationText: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginLeft: Spacing.xs,
  },
  sessionDetails: {
    gap: Spacing.sm,
  },
  detailRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  detailLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
  },
  detailValue: {
    ...Typography.body,
    color: Colors.light.text,
  },
  comfortBadge: {
    backgroundColor: Colors.light.accent + "30",
    paddingVertical: Spacing.xs,
    paddingHorizontal: Spacing.sm,
    borderRadius: BorderRadius.xs,
  },
  comfortText: {
    ...Typography.caption,
    color: Colors.light.text,
  },
  notesSection: {
    marginTop: Spacing.md,
    paddingTop: Spacing.md,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border,
  },
  notesLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginBottom: Spacing.xs,
  },
  notesText: {
    ...Typography.body,
    color: Colors.light.text,
  },
  emptyState: {
    alignItems: "center",
    paddingHorizontal: Spacing["2xl"],
  },
  emptyImage: {
    width: 200,
    height: 200,
    marginBottom: Spacing.xl,
  },
  emptyTitle: {
    ...Typography.title,
    color: Colors.light.text,
    marginBottom: Spacing.sm,
  },
  emptyText: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    textAlign: "center",
  },
});
-e 
========== FILE: ./client/screens/DisclaimerModalScreen.tsx ==========
import React from "react";
import { View, StyleSheet, ScrollView } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useHeaderHeight } from "@react-navigation/elements";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { DISCLAIMERS } from "@/constants/disclaimers";

export default function DisclaimerModalScreen() {
  const insets = useSafeAreaInsets();
  const headerHeight = useHeaderHeight();

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={[
        styles.content,
        {
          paddingTop: headerHeight + Spacing.lg,
          paddingBottom: insets.bottom + Spacing["2xl"],
        },
      ]}
    >
      <View style={styles.section}>
        <ThemedText style={styles.sectionTitle}>Wellness Disclaimer</ThemedText>
        <View style={styles.disclaimerBox}>
          <ThemedText style={styles.disclaimerText}>{DISCLAIMERS.MASTER}</ThemedText>
        </View>
      </View>

      <View style={styles.section}>
        <ThemedText style={styles.sectionTitle}>Device Placement</ThemedText>
        <View style={styles.infoBox}>
          <ThemedText style={styles.infoText}>{DISCLAIMERS.PLACEMENT_GUIDE}</ThemedText>
        </View>
      </View>

      <View style={styles.section}>
        <ThemedText style={styles.sectionTitle}>Vibration Settings</ThemedText>
        <View style={styles.infoBox}>
          <ThemedText style={styles.infoText}>{DISCLAIMERS.VIBRATION_PARAMS}</ThemedText>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  content: {
    paddingHorizontal: Spacing.xl,
  },
  section: {
    marginBottom: Spacing.xl,
  },
  sectionTitle: {
    ...Typography.title,
    color: Colors.light.text,
    marginBottom: Spacing.md,
  },
  disclaimerBox: {
    backgroundColor: Colors.light.warning + "30",
    borderRadius: BorderRadius.md,
    padding: Spacing.lg,
    borderWidth: 1,
    borderColor: Colors.light.warning,
  },
  disclaimerText: {
    ...Typography.body,
    color: Colors.light.text,
  },
  infoBox: {
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.md,
    padding: Spacing.lg,
    borderWidth: 1,
    borderColor: Colors.light.border,
  },
  infoText: {
    ...Typography.body,
    color: Colors.light.textSecondary,
  },
});
-e 
========== FILE: ./client/screens/AboutScreen.tsx ==========
import React from "react";
import { View, StyleSheet, ScrollView, Image } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useHeaderHeight } from "@react-navigation/elements";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";

import appIcon from "../../assets/images/icon.png";

export default function AboutScreen() {
  const insets = useSafeAreaInsets();
  const headerHeight = useHeaderHeight();

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={[
        styles.content,
        {
          paddingTop: headerHeight + Spacing.lg,
          paddingBottom: insets.bottom + Spacing["2xl"],
        },
      ]}
    >
      <View style={styles.logoSection}>
        <Image source={appIcon} style={styles.logo} resizeMode="contain" />
        <ThemedText style={styles.appName}>Alivio Ease</ThemedText>
        <ThemedText style={styles.version}>Version 1.0.0</ThemedText>
      </View>

      <View style={styles.section}>
        <ThemedText style={styles.sectionTitle}>About</ThemedText>
        <ThemedText style={styles.paragraph}>
          Alivio Ease is a wellness companion designed to support relaxation and 
          comfort during routine self-care moments through gentle sensory distraction.
        </ThemedText>
        <ThemedText style={styles.paragraph}>
          Using a combination of haptic vibration patterns, calming audio, and 
          visual focus techniques featuring Ali the dragonfly, Alivio Ease helps 
          create a sense of calm during your personal care routines.
        </ThemedText>
      </View>

      <View style={styles.section}>
        <ThemedText style={styles.sectionTitle}>Meet Ali</ThemedText>
        <ThemedText style={styles.paragraph}>
          Ali is your friendly dragonfly companion who appears during sessions 
          to provide a gentle focal point for visual distraction. Watch Ali's 
          peaceful movements to help center your attention and promote calmness.
        </ThemedText>
      </View>

      <View style={styles.section}>
        <ThemedText style={styles.sectionTitle}>How It Works</ThemedText>
        <View style={styles.featureList}>
          <View style={styles.feature}>
            <ThemedText style={styles.featureTitle}>Haptic Patterns</ThemedText>
            <ThemedText style={styles.featureDescription}>
              Choose from three gentle vibration patterns designed to provide 
              sensory distraction during your sessions.
            </ThemedText>
          </View>
          <View style={styles.feature}>
            <ThemedText style={styles.featureTitle}>Audio Feedback</ThemedText>
            <ThemedText style={styles.featureDescription}>
              Calming sounds signal the start and completion of your sessions, 
              helping you stay present and relaxed.
            </ThemedText>
          </View>
          <View style={styles.feature}>
            <ThemedText style={styles.featureTitle}>Session Tracking</ThemedText>
            <ThemedText style={styles.featureDescription}>
              Track your comfort levels over time to understand what works 
              best for you.
            </ThemedText>
          </View>
        </View>
      </View>

      <View style={styles.footer}>
        <ThemedText style={styles.footerText}>
          Alivio Ease is a wellness tool, not a medical device.
        </ThemedText>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  content: {
    paddingHorizontal: Spacing.xl,
  },
  logoSection: {
    alignItems: "center",
    marginBottom: Spacing["2xl"],
  },
  logo: {
    width: 80,
    height: 80,
    borderRadius: 16,
    marginBottom: Spacing.md,
  },
  appName: {
    ...Typography.headline,
    color: Colors.light.primary,
  },
  version: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginTop: Spacing.xs,
  },
  section: {
    marginBottom: Spacing.xl,
  },
  sectionTitle: {
    ...Typography.title,
    color: Colors.light.text,
    marginBottom: Spacing.md,
  },
  paragraph: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    marginBottom: Spacing.md,
  },
  featureList: {
    gap: Spacing.lg,
  },
  feature: {
    backgroundColor: Colors.light.surface,
    padding: Spacing.lg,
    borderRadius: BorderRadius.sm,
    borderWidth: 1,
    borderColor: Colors.light.border,
  },
  featureTitle: {
    ...Typography.button,
    color: Colors.light.text,
    marginBottom: Spacing.xs,
  },
  featureDescription: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
  },
  footer: {
    alignItems: "center",
    paddingVertical: Spacing.xl,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border,
  },
  footerText: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    textAlign: "center",
    fontStyle: "italic",
  },
});
-e 
========== FILE: ./client/screens/onboarding/WelcomeScreen.tsx ==========
import React from "react";
import { View, StyleSheet, Pressable, Image } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { LinearGradient } from "expo-linear-gradient";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import type { OnboardingStackParamList } from "@/navigation/OnboardingNavigator";
import onboardingHero from "../../../assets/images/onboarding-hero.png";

type NavigationProp = NativeStackNavigationProp<OnboardingStackParamList, "Welcome">;

export default function WelcomeScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<NavigationProp>();

  return (
    <LinearGradient
      colors={[Colors.light.background, Colors.light.accent + "30"]}
      style={styles.container}
    >
      <View style={[styles.content, { paddingTop: insets.top + Spacing["3xl"] }]}>
        <View style={styles.heroContainer}>
          <Image
            source={onboardingHero}
            style={styles.heroImage}
            resizeMode="contain"
          />
        </View>

        <View style={styles.textContainer}>
          <ThemedText style={styles.title}>Alivio Ease</ThemedText>
          <ThemedText style={styles.subtitle}>
            Your companion for calm moments
          </ThemedText>
          <ThemedText style={styles.description}>
            Gentle sensory distraction to support your comfort during routine self-care
          </ThemedText>
        </View>
      </View>

      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing["2xl"] }]}>
        <Pressable
          style={({ pressed }) => [
            styles.button,
            pressed && styles.buttonPressed,
          ]}
          onPress={() => navigation.navigate("Disclaimer")}
          testID="button-continue"
        >
          <ThemedText style={styles.buttonText}>Get Started</ThemedText>
        </Pressable>
      </View>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    alignItems: "center",
    paddingHorizontal: Spacing["2xl"],
  },
  heroContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    maxHeight: 320,
  },
  heroImage: {
    width: 280,
    height: 280,
  },
  textContainer: {
    alignItems: "center",
    paddingVertical: Spacing["3xl"],
  },
  title: {
    ...Typography.headline,
    fontSize: 36,
    color: Colors.light.primary,
    marginBottom: Spacing.sm,
  },
  subtitle: {
    ...Typography.title,
    color: Colors.light.text,
    marginBottom: Spacing.lg,
    textAlign: "center",
  },
  description: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    textAlign: "center",
    maxWidth: 300,
  },
  footer: {
    paddingHorizontal: Spacing["2xl"],
  },
  button: {
    backgroundColor: Colors.light.primary,
    paddingVertical: Spacing.lg,
    borderRadius: BorderRadius.md,
    alignItems: "center",
  },
  buttonPressed: {
    opacity: 0.7,
  },
  buttonText: {
    ...Typography.button,
    color: Colors.light.buttonText,
  },
});
-e 
========== FILE: ./client/screens/onboarding/DisclaimerScreen.tsx ==========
import React, { useState } from "react";
import { View, StyleSheet, Pressable, ScrollView } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import { Platform } from "react-native";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { DISCLAIMERS } from "@/constants/disclaimers";
import { useApp } from "@/context/AppContext";
import type { OnboardingStackParamList } from "@/navigation/OnboardingNavigator";

type NavigationProp = NativeStackNavigationProp<OnboardingStackParamList, "Disclaimer">;

export default function DisclaimerScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<NavigationProp>();
  const { updateOnboarding } = useApp();
  const [accepted, setAccepted] = useState(false);

  const handleToggle = async () => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setAccepted(!accepted);
  };

  const handleContinue = async () => {
    if (!accepted) return;
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
    await updateOnboarding({ disclaimerAccepted: true });
    navigation.navigate("AgeVerification");
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top + Spacing["2xl"] }]}>
      <View style={styles.header}>
        <ThemedText style={styles.title}>Important Information</ThemedText>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={true}
      >
        <View style={styles.disclaimerBox}>
          <ThemedText style={styles.disclaimerText}>
            {DISCLAIMERS.MASTER}
          </ThemedText>
        </View>
      </ScrollView>

      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing["2xl"] }]}>
        <Pressable
          style={styles.checkboxRow}
          onPress={handleToggle}
          testID="checkbox-disclaimer"
        >
          <View style={[styles.checkbox, accepted && styles.checkboxChecked]}>
            {accepted ? (
              <Feather name="check" size={16} color={Colors.light.buttonText} />
            ) : null}
          </View>
          <ThemedText style={styles.checkboxLabel}>
            I understand this is a wellness tool, not medical advice
          </ThemedText>
        </Pressable>

        <Pressable
          style={({ pressed }) => [
            styles.button,
            !accepted && styles.buttonDisabled,
            pressed && accepted && styles.buttonPressed,
          ]}
          onPress={handleContinue}
          disabled={!accepted}
          testID="button-continue"
        >
          <ThemedText style={styles.buttonText}>Continue</ThemedText>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    paddingHorizontal: Spacing["2xl"],
    paddingBottom: Spacing.lg,
    alignItems: "center",
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingHorizontal: Spacing["2xl"],
    paddingBottom: Spacing.lg,
  },
  disclaimerBox: {
    backgroundColor: Colors.light.warning + "30",
    borderRadius: BorderRadius.md,
    padding: Spacing.xl,
    borderWidth: 1,
    borderColor: Colors.light.warning,
  },
  disclaimerText: {
    ...Typography.body,
    color: Colors.light.text,
  },
  footer: {
    paddingHorizontal: Spacing["2xl"],
    paddingTop: Spacing.lg,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border,
    backgroundColor: Colors.light.background,
  },
  checkboxRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: Spacing.xl,
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: BorderRadius.xs,
    borderWidth: 2,
    borderColor: Colors.light.primary,
    marginRight: Spacing.md,
    alignItems: "center",
    justifyContent: "center",
  },
  checkboxChecked: {
    backgroundColor: Colors.light.primary,
  },
  checkboxLabel: {
    ...Typography.body,
    color: Colors.light.text,
    flex: 1,
  },
  button: {
    backgroundColor: Colors.light.primary,
    paddingVertical: Spacing.lg,
    borderRadius: BorderRadius.md,
    alignItems: "center",
  },
  buttonDisabled: {
    backgroundColor: Colors.light.border,
  },
  buttonPressed: {
    opacity: 0.7,
  },
  buttonText: {
    ...Typography.button,
    color: Colors.light.buttonText,
  },
});
-e 
========== FILE: ./client/screens/onboarding/ParentalConsentScreen.tsx ==========
import React, { useState } from "react";
import { View, StyleSheet, Pressable, ScrollView, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { DISCLAIMERS } from "@/constants/disclaimers";
import { useApp } from "@/context/AppContext";
import type { OnboardingStackParamList } from "@/navigation/OnboardingNavigator";

type NavigationProp = NativeStackNavigationProp<OnboardingStackParamList, "ParentalConsent">;

export default function ParentalConsentScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<NavigationProp>();
  const { updateOnboarding } = useApp();
  const [consent, setConsent] = useState(false);

  const handleToggle = async () => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setConsent(!consent);
  };

  const handleContinue = async () => {
    if (!consent) return;
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
    await updateOnboarding({ parentalConsentGiven: true });
    navigation.navigate("Preferences");
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top + Spacing["2xl"] }]}>
      <View style={styles.header}>
        <Feather name="shield" size={48} color={Colors.light.primary} />
        <ThemedText style={styles.title}>Parental Permission Required</ThemedText>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={true}
      >
        <ThemedText style={styles.instruction}>
          Please have a parent or guardian read the following and provide consent:
        </ThemedText>

        <View style={styles.consentBox}>
          <ThemedText style={styles.consentText}>
            {DISCLAIMERS.PARENTAL_CONSENT}
          </ThemedText>
        </View>
      </ScrollView>

      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing["2xl"] }]}>
        <Pressable
          style={styles.checkboxRow}
          onPress={handleToggle}
          testID="checkbox-consent"
        >
          <View style={[styles.checkbox, consent && styles.checkboxChecked]}>
            {consent ? (
              <Feather name="check" size={16} color={Colors.light.buttonText} />
            ) : null}
          </View>
          <ThemedText style={styles.checkboxLabel}>
            I am a parent/guardian and I consent to my child using this wellness app
          </ThemedText>
        </Pressable>

        <Pressable
          style={({ pressed }) => [
            styles.button,
            !consent && styles.buttonDisabled,
            pressed && consent && styles.buttonPressed,
          ]}
          onPress={handleContinue}
          disabled={!consent}
          testID="button-continue"
        >
          <ThemedText style={styles.buttonText}>Continue</ThemedText>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    alignItems: "center",
    paddingHorizontal: Spacing["2xl"],
    paddingBottom: Spacing.lg,
  },
  title: {
    ...Typography.title,
    color: Colors.light.text,
    marginTop: Spacing.lg,
    textAlign: "center",
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingHorizontal: Spacing["2xl"],
    paddingBottom: Spacing.lg,
  },
  instruction: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    textAlign: "center",
    marginBottom: Spacing.xl,
  },
  consentBox: {
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.md,
    padding: Spacing.xl,
    borderWidth: 1,
    borderColor: Colors.light.border,
  },
  consentText: {
    ...Typography.body,
    color: Colors.light.text,
  },
  footer: {
    paddingHorizontal: Spacing["2xl"],
    paddingTop: Spacing.lg,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border,
    backgroundColor: Colors.light.background,
  },
  checkboxRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: Spacing.xl,
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: BorderRadius.xs,
    borderWidth: 2,
    borderColor: Colors.light.primary,
    marginRight: Spacing.md,
    alignItems: "center",
    justifyContent: "center",
  },
  checkboxChecked: {
    backgroundColor: Colors.light.primary,
  },
  checkboxLabel: {
    ...Typography.body,
    color: Colors.light.text,
    flex: 1,
  },
  button: {
    backgroundColor: Colors.light.primary,
    paddingVertical: Spacing.lg,
    borderRadius: BorderRadius.md,
    alignItems: "center",
  },
  buttonDisabled: {
    backgroundColor: Colors.light.border,
  },
  buttonPressed: {
    opacity: 0.7,
  },
  buttonText: {
    ...Typography.button,
    color: Colors.light.buttonText,
  },
});
-e 
========== FILE: ./client/screens/onboarding/PreferencesScreen.tsx ==========
import React, { useState } from "react";
import { View, StyleSheet, Pressable, TextInput, Switch, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import Slider from "@react-native-community/slider";
import * as Haptics from "expo-haptics";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";

export default function PreferencesScreen() {
  const insets = useSafeAreaInsets();
  const { updateOnboarding, updatePreferences } = useApp();
  const [name, setName] = useState("");
  const [hapticIntensity, setHapticIntensity] = useState(0.5);
  const [audioEnabled, setAudioEnabled] = useState(true);

  const handleComplete = async () => {
    if (Platform.OS !== "web") {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
    await updatePreferences({
      displayName: name || "Friend",
      hapticIntensity,
      audioEnabled,
    });
    await updateOnboarding({ completed: true });
  };

  const handleSliderChange = async (value: number) => {
    setHapticIntensity(value);
    if (Platform.OS !== "web" && Math.abs(value - hapticIntensity) > 0.1) {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top + Spacing["3xl"] }]}>
      <View style={styles.content}>
        <ThemedText style={styles.title}>Personalize Your Experience</ThemedText>
        <ThemedText style={styles.subtitle}>
          You can always change these later in settings
        </ThemedText>

        <View style={styles.formGroup}>
          <ThemedText style={styles.label}>What should we call you?</ThemedText>
          <TextInput
            style={styles.input}
            value={name}
            onChangeText={setName}
            placeholder="Enter your name"
            placeholderTextColor={Colors.light.textSecondary}
            testID="input-name"
          />
        </View>

        <View style={styles.formGroup}>
          <ThemedText style={styles.label}>Haptic Intensity</ThemedText>
          <View style={styles.sliderContainer}>
            <ThemedText style={styles.sliderLabel}>Gentle</ThemedText>
            <Slider
              style={styles.slider}
              minimumValue={0.1}
              maximumValue={1}
              value={hapticIntensity}
              onValueChange={handleSliderChange}
              minimumTrackTintColor={Colors.light.primary}
              maximumTrackTintColor={Colors.light.border}
              thumbTintColor={Colors.light.primary}
              testID="slider-haptic"
            />
            <ThemedText style={styles.sliderLabel}>Strong</ThemedText>
          </View>
        </View>

        <View style={styles.formGroup}>
          <View style={styles.switchRow}>
            <ThemedText style={styles.label}>Sound Effects</ThemedText>
            <Switch
              value={audioEnabled}
              onValueChange={setAudioEnabled}
              trackColor={{ false: Colors.light.border, true: Colors.light.accent }}
              thumbColor={Colors.light.surface}
              testID="switch-audio"
            />
          </View>
          <ThemedText style={styles.switchDescription}>
            Play calming sounds during sessions
          </ThemedText>
        </View>
      </View>

      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing["2xl"] }]}>
        <Pressable
          style={({ pressed }) => [
            styles.button,
            pressed && styles.buttonPressed,
          ]}
          onPress={handleComplete}
          testID="button-complete"
        >
          <ThemedText style={styles.buttonText}>Start Using Alivio Ease</ThemedText>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  content: {
    flex: 1,
    paddingHorizontal: Spacing["2xl"],
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
    marginBottom: Spacing.sm,
  },
  subtitle: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    marginBottom: Spacing["3xl"],
  },
  formGroup: {
    marginBottom: Spacing["2xl"],
  },
  label: {
    ...Typography.button,
    color: Colors.light.text,
    marginBottom: Spacing.sm,
  },
  input: {
    ...Typography.body,
    color: Colors.light.text,
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.sm,
    paddingVertical: Spacing.lg,
    paddingHorizontal: Spacing.lg,
    borderWidth: 1,
    borderColor: Colors.light.border,
  },
  sliderContainer: {
    flexDirection: "row",
    alignItems: "center",
  },
  slider: {
    flex: 1,
    height: 40,
  },
  sliderLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    width: 50,
    textAlign: "center",
  },
  switchRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  switchDescription: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginTop: Spacing.xs,
  },
  footer: {
    paddingHorizontal: Spacing["2xl"],
  },
  button: {
    backgroundColor: Colors.light.primary,
    paddingVertical: Spacing.lg,
    borderRadius: BorderRadius.md,
    alignItems: "center",
  },
  buttonPressed: {
    opacity: 0.7,
  },
  buttonText: {
    ...Typography.button,
    color: Colors.light.buttonText,
  },
});
-e 
========== FILE: ./client/screens/onboarding/AgeVerificationScreen.tsx ==========
import React, { useState } from "react";
import { View, StyleSheet, Pressable, TextInput, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation } from "@react-navigation/native";
import * as Haptics from "expo-haptics";
import { ThemedText } from "@/components/ThemedText";
import { BackButton } from "@/components/BackButton";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";

export default function AgeVerificationScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation();
  const { onboarding, updateOnboarding } = useApp();
  const [age, setAge] = useState("");

  const ageNumber = parseInt(age, 10);
  const isValidAge = !isNaN(ageNumber) && ageNumber > 0 && ageNumber <= 130;

  const handleContinue = async () => {
    if (!isValidAge) return;

    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }

    await updateOnboarding({ age: ageNumber });

    if (ageNumber < 18) {
      navigation.navigate("ParentalConsent");
    } else {
      navigation.navigate("Preferences");
    }
  };

  return (
    <View style={styles.container}>
      <View
        style={{
          position: "absolute",
          top: insets.top + 8,
          left: 8,
          zIndex: 10,
        }}
      >
        <BackButton />
      </View>
      <View
        style={[styles.content, { paddingTop: insets.top + Spacing["3xl"] }]}
      >
        <ThemedText style={styles.title}>What's your age?</ThemedText>
        <ThemedText style={styles.subtitle}>
          This helps us personalize your experience
        </ThemedText>
        <View style={styles.inputContainer}>
          <TextInput
            style={styles.input}
            value={age}
            onChangeText={setAge}
            keyboardType="number-pad"
            maxLength={3}
            placeholder="Enter age"
            placeholderTextColor={Colors.light.textSecondary}
            testID="input-age"
          />
        </View>
        {ageNumber > 0 && ageNumber < 18 ? (
          <View style={styles.notice}>
            <ThemedText style={styles.noticeText}>
              A parent or guardian will need to provide consent
            </ThemedText>
          </View>
        ) : null}
        <Pressable
          style={({ pressed }) => [
            styles.button,
            !isValidAge && styles.buttonDisabled,
            pressed && isValidAge && styles.buttonPressed,
          ]}
          onPress={handleContinue}
          disabled={!isValidAge}
          testID="button-continue"
        >
          <ThemedText style={styles.buttonText}>Continue</ThemedText>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  content: {
    flex: 1,
    alignItems: "center",
    paddingHorizontal: Spacing["2xl"],
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
    marginBottom: Spacing.sm,
  },
  subtitle: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    textAlign: "center",
    marginBottom: Spacing["3xl"],
  },
  inputContainer: {
    width: "100%",
    maxWidth: 200,
  },
  input: {
    ...Typography.headline,
    fontSize: 48,
    color: Colors.light.text,
    textAlign: "center",
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.md,
    paddingVertical: Spacing.xl,
    paddingHorizontal: Spacing["2xl"],
    borderWidth: 2,
    borderColor: Colors.light.border,
  },
  notice: {
    marginTop: Spacing["2xl"],
    paddingHorizontal: Spacing["2xl"],
    paddingVertical: Spacing.xl,
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.md,
    borderLeftWidth: 4,
    borderLeftColor: Colors.light.accent,
  },
  noticeText: {
    ...Typography.body,
    color: Colors.light.text,
    textAlign: "center",
  },
  button: {
    marginTop: Spacing.xl,
    paddingVertical: Spacing.lg,
    paddingHorizontal: Spacing["3xl"],
    backgroundColor: Colors.light.accent,
    borderRadius: BorderRadius.lg,
  },
  buttonDisabled: {
    opacity: 0.5,
  },
  buttonPressed: {
    opacity: 0.8,
  },
  buttonText: {
    ...Typography.body,
    color: "white",
    fontWeight: "600",
    textAlign: "center",
  },
});
-e 
========== FILE: ./client/screens/ComfortRatingScreen.tsx ==========
import React, { useState } from "react";
import { View, StyleSheet, Pressable, TextInput, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation, useRoute } from "@react-navigation/native";
import type { NativeStackNavigationProp, NativeStackScreenProps } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";
import { COMFORT_LABELS, SESSION_SITE_LABELS } from "@/types";
import type { RootStackParamList } from "@/navigation/RootStackNavigator";
import type { ComfortRating, SessionLog } from "@/types";

type RouteProp = NativeStackScreenProps<RootStackParamList, "ComfortRating">["route"];
type NavigationProp = NativeStackNavigationProp<RootStackParamList>;

const RATINGS: ComfortRating[] = [1, 2, 3, 4, 5];

export default function ComfortRatingScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RouteProp>();
  const { addSession } = useApp();
  const { duration, hapticPattern, site } = route.params;
  
  const [selectedRating, setSelectedRating] = useState<ComfortRating | null>(null);
  const [showNotes, setShowNotes] = useState(false);
  const [notes, setNotes] = useState("");

  const handleRatingSelect = async (rating: ComfortRating) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setSelectedRating(rating);
  };

  const handleSave = async () => {
    if (selectedRating === null) return;

    if (Platform.OS !== "web") {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }

    const session: SessionLog = {
      id: Date.now().toString(),
      date: new Date().toISOString(),
      duration,
      hapticPattern,
      comfortRating: selectedRating,
      site: site,
      notes: notes.trim() || undefined,
    };

    await addSession(session);
    navigation.navigate("Main");
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top + Spacing["3xl"] }]}>
      <View style={styles.content}>
        <ThemedText style={styles.title}>How do you feel?</ThemedText>
        <ThemedText style={styles.subtitle}>
          Rate your comfort level after this session
        </ThemedText>

        {site && (
          <View style={styles.siteIndicator}>
            <Feather name="map-pin" size={14} color={Colors.light.textSecondary} />
            <ThemedText style={styles.siteText}>{SESSION_SITE_LABELS[site]}</ThemedText>
          </View>
        )}

        <View style={styles.ratingsContainer}>
          {RATINGS.map((rating) => (
            <Pressable
              key={rating}
              style={({ pressed }) => [
                styles.ratingButton,
                selectedRating === rating && styles.ratingButtonSelected,
                pressed && styles.ratingButtonPressed,
              ]}
              onPress={() => handleRatingSelect(rating)}
              testID={`rating-${rating}`}
            >
              <ThemedText
                style={[
                  styles.ratingText,
                  selectedRating === rating && styles.ratingTextSelected,
                ]}
              >
                {COMFORT_LABELS[rating]}
              </ThemedText>
            </Pressable>
          ))}
        </View>

        {showNotes ? (
          <View style={styles.notesContainer}>
            <TextInput
              style={styles.notesInput}
              value={notes}
              onChangeText={setNotes}
              placeholder="Add any notes about your session..."
              placeholderTextColor={Colors.light.textSecondary}
              multiline
              numberOfLines={4}
              textAlignVertical="top"
              testID="input-notes"
            />
          </View>
        ) : (
          <Pressable
            style={styles.addNotesButton}
            onPress={() => setShowNotes(true)}
            testID="button-add-notes"
          >
            <Feather name="edit-3" size={16} color={Colors.light.textSecondary} />
            <ThemedText style={styles.addNotesText}>Add notes</ThemedText>
          </Pressable>
        )}
      </View>

      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing["2xl"] }]}>
        <Pressable
          style={({ pressed }) => [
            styles.saveButton,
            selectedRating === null && styles.saveButtonDisabled,
            pressed && selectedRating !== null && styles.saveButtonPressed,
          ]}
          onPress={handleSave}
          disabled={selectedRating === null}
          testID="button-save"
        >
          <ThemedText style={styles.saveButtonText}>Save & Close</ThemedText>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  content: {
    flex: 1,
    paddingHorizontal: Spacing.xl,
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
    textAlign: "center",
    marginBottom: Spacing.sm,
  },
  subtitle: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    textAlign: "center",
    marginBottom: Spacing.lg,
  },
  siteIndicator: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    marginBottom: Spacing.xl,
    gap: Spacing.xs,
  },
  siteText: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
  },
  ratingsContainer: {
    gap: Spacing.md,
  },
  ratingButton: {
    backgroundColor: Colors.light.surface,
    paddingVertical: Spacing.lg,
    paddingHorizontal: Spacing.xl,
    borderRadius: BorderRadius.md,
    borderWidth: 1,
    borderColor: Colors.light.border,
    alignItems: "center",
  },
  ratingButtonSelected: {
    backgroundColor: Colors.light.accent + "30",
    borderColor: Colors.light.accent,
  },
  ratingButtonPressed: {
    opacity: 0.7,
  },
  ratingText: {
    ...Typography.button,
    color: Colors.light.text,
  },
  ratingTextSelected: {
    color: Colors.light.text,
  },
  addNotesButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    marginTop: Spacing.xl,
    paddingVertical: Spacing.md,
  },
  addNotesText: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginLeft: Spacing.sm,
  },
  notesContainer: {
    marginTop: Spacing.xl,
  },
  notesInput: {
    ...Typography.body,
    color: Colors.light.text,
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.sm,
    padding: Spacing.lg,
    borderWidth: 1,
    borderColor: Colors.light.border,
    minHeight: 100,
  },
  footer: {
    paddingHorizontal: Spacing.xl,
  },
  saveButton: {
    backgroundColor: Colors.light.primary,
    paddingVertical: Spacing.lg,
    borderRadius: BorderRadius.md,
    alignItems: "center",
  },
  saveButtonDisabled: {
    backgroundColor: Colors.light.border,
  },
  saveButtonPressed: {
    opacity: 0.7,
  },
  saveButtonText: {
    ...Typography.button,
    color: Colors.light.buttonText,
  },
});
-e 
========== FILE: ./client/screens/HomeScreen.tsx ==========
import React, { useState, useEffect } from "react";
import { View, StyleSheet, Pressable, ScrollView, Animated } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useBottomTabBarHeight } from "@react-navigation/bottom-tabs";
import { useNavigation } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";
import { LinearGradient } from "expo-linear-gradient";
import * as Haptics from "expo-haptics";
import { Platform } from "react-native";
import { ThemedText } from "@/components/ThemedText";
import { Card } from "@/components/Card";
import { Colors, Spacing, BorderRadius, Typography, Shadows } from "@/constants/theme";
import { WELLNESS_TIPS } from "@/constants/disclaimers";
import { useApp } from "@/context/AppContext";
import type { RootStackParamList } from "@/navigation/RootStackNavigator";
import type { SessionSite, SessionDuration } from "@/types";
import { SESSION_SITE_LABELS, SESSION_DURATION_LABELS } from "@/types";

type NavigationProp = NativeStackNavigationProp<RootStackParamList>;

const SITES: SessionSite[] = [
  'arm-left', 'arm-right', 
  'thigh-left', 'thigh-right', 
  'abdomen-left', 'abdomen-right',
  'other'
];

const DURATIONS: SessionDuration[] = [18, 24, 30];

const SITE_ICONS: Record<SessionSite, string> = {
  'arm-left': 'circle',
  'arm-right': 'circle',
  'thigh-left': 'circle',
  'thigh-right': 'circle',
  'abdomen-left': 'circle',
  'abdomen-right': 'circle',
  'other': 'more-horizontal',
};

export default function HomeScreen() {
  const insets = useSafeAreaInsets();
  const tabBarHeight = useBottomTabBarHeight();
  const navigation = useNavigation<NavigationProp>();
  const { preferences, sessionsThisWeek, updatePreferences } = useApp();
  const [tipIndex, setTipIndex] = useState(0);
  const [showTip, setShowTip] = useState(true);
  const [selectedSite, setSelectedSite] = useState<SessionSite | undefined>(preferences.lastSelectedSite);
  const [selectedDuration, setSelectedDuration] = useState<SessionDuration>(preferences.selectedDuration || 24);
  const fadeAnim = useState(new Animated.Value(0))[0];

  useEffect(() => {
    setTipIndex(Math.floor(Math.random() * WELLNESS_TIPS.length));
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 600,
      useNativeDriver: true,
    }).start();
  }, []);

  useEffect(() => {
    if (preferences.lastSelectedSite) {
      setSelectedSite(preferences.lastSelectedSite);
    }
    if (preferences.selectedDuration) {
      setSelectedDuration(preferences.selectedDuration);
    }
  }, [preferences.lastSelectedSite, preferences.selectedDuration]);

  const displayName = preferences.displayName || "Friend";
  const greeting = getGreeting();

  function getGreeting() {
    const hour = new Date().getHours();
    if (hour < 12) return "Good morning";
    if (hour < 17) return "Good afternoon";
    return "Good evening";
  }

  const handleSiteSelect = async (site: SessionSite) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setSelectedSite(site);
    await updatePreferences({ lastSelectedSite: site });
  };

  const handleDurationSelect = async (duration: SessionDuration) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setSelectedDuration(duration);
    await updatePreferences({ selectedDuration: duration });
  };

  const handleStartSession = async () => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
    navigation.navigate("Session", { 
      site: selectedSite,
      duration: selectedDuration 
    });
  };

  const dismissTip = () => {
    setShowTip(false);
  };

  return (
    <LinearGradient
      colors={[Colors.light.background, Colors.light.accent + "15"]}
      style={styles.container}
    >
      <Animated.ScrollView
        style={styles.scrollView}
        contentContainerStyle={[
          styles.scrollContent,
          {
            paddingTop: insets.top + Spacing["3xl"],
            paddingBottom: tabBarHeight + 100 + Spacing["2xl"],
          },
        ]}
        showsVerticalScrollIndicator={false}
      >
        <Animated.View style={[styles.content, { opacity: fadeAnim }]}>
          <ThemedText style={styles.greeting}>
            {greeting}, {displayName}
          </ThemedText>
          <ThemedText style={styles.tagline}>Ready for calm?</ThemedText>

          <Card style={styles.statsCard}>
            <View style={styles.statsRow}>
              <View style={styles.statItem}>
                <ThemedText style={styles.statValue}>{sessionsThisWeek}</ThemedText>
                <ThemedText style={styles.statLabel}>Sessions this week</ThemedText>
              </View>
            </View>
          </Card>

          <ThemedText style={styles.sectionTitle}>Select Site</ThemedText>
          <Card style={styles.siteCard}>
            <View style={styles.siteGrid}>
              {SITES.map((site) => (
                <Pressable
                  key={site}
                  style={({ pressed }) => [
                    styles.siteButton,
                    selectedSite === site && styles.siteButtonSelected,
                    pressed && styles.siteButtonPressed,
                  ]}
                  onPress={() => handleSiteSelect(site)}
                  testID={`button-site-${site}`}
                >
                  <Feather 
                    name={SITE_ICONS[site] as any} 
                    size={16} 
                    color={selectedSite === site ? Colors.light.buttonText : Colors.light.textSecondary} 
                  />
                  <ThemedText
                    style={[
                      styles.siteButtonText,
                      selectedSite === site && styles.siteButtonTextSelected,
                    ]}
                  >
                    {SESSION_SITE_LABELS[site]}
                  </ThemedText>
                </Pressable>
              ))}
            </View>
          </Card>

          <ThemedText style={styles.sectionTitle}>Session Duration</ThemedText>
          <Card style={styles.durationCard}>
            <View style={styles.durationRow}>
              {DURATIONS.map((duration) => (
                <Pressable
                  key={duration}
                  style={({ pressed }) => [
                    styles.durationButton,
                    selectedDuration === duration && styles.durationButtonSelected,
                    pressed && styles.durationButtonPressed,
                  ]}
                  onPress={() => handleDurationSelect(duration)}
                  testID={`button-duration-${duration}`}
                >
                  <ThemedText
                    style={[
                      styles.durationValue,
                      selectedDuration === duration && styles.durationValueSelected,
                    ]}
                  >
                    {duration}s
                  </ThemedText>
                  <ThemedText
                    style={[
                      styles.durationLabel,
                      selectedDuration === duration && styles.durationLabelSelected,
                    ]}
                  >
                    {duration === 18 ? 'Quick' : duration === 24 ? 'Standard' : 'Extended'}
                  </ThemedText>
                </Pressable>
              ))}
            </View>
          </Card>

          {showTip ? (
            <Card style={styles.tipCard}>
              <View style={styles.tipHeader}>
                <View style={styles.tipIconContainer}>
                  <Feather name="sun" size={20} color={Colors.light.primary} />
                </View>
                <ThemedText style={styles.tipTitle}>Wellness Tip</ThemedText>
                <Pressable
                  onPress={dismissTip}
                  hitSlop={8}
                  testID="button-dismiss-tip"
                >
                  <Feather name="x" size={20} color={Colors.light.textSecondary} />
                </Pressable>
              </View>
              <ThemedText style={styles.tipText}>{WELLNESS_TIPS[tipIndex]}</ThemedText>
            </Card>
          ) : null}
        </Animated.View>
      </Animated.ScrollView>

      <View
        style={[
          styles.fabContainer,
          { bottom: tabBarHeight + Spacing.xl },
        ]}
      >
        <Pressable
          style={({ pressed }) => [
            styles.fab,
            pressed && styles.fabPressed,
          ]}
          onPress={handleStartSession}
          testID="button-start-session"
        >
          <LinearGradient
            colors={[Colors.light.primary, Colors.light.primary + "DD"]}
            style={styles.fabGradient}
          >
            <Feather name="play" size={28} color={Colors.light.buttonText} />
            <ThemedText style={styles.fabText}>Start Session</ThemedText>
          </LinearGradient>
        </Pressable>
      </View>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingHorizontal: Spacing.xl,
  },
  content: {
    flex: 1,
  },
  greeting: {
    ...Typography.headline,
    color: Colors.light.text,
  },
  tagline: {
    ...Typography.title,
    color: Colors.light.textSecondary,
    marginTop: Spacing.xs,
    marginBottom: Spacing["2xl"],
  },
  statsCard: {
    marginBottom: Spacing.lg,
  },
  statsRow: {
    flexDirection: "row",
    justifyContent: "center",
  },
  statItem: {
    alignItems: "center",
  },
  statValue: {
    ...Typography.headline,
    fontSize: 36,
    color: Colors.light.primary,
  },
  statLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
  },
  sectionTitle: {
    ...Typography.button,
    color: Colors.light.textSecondary,
    marginBottom: Spacing.sm,
    marginLeft: Spacing.xs,
  },
  siteCard: {
    marginBottom: Spacing.lg,
  },
  siteGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: Spacing.sm,
  },
  siteButton: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: Spacing.sm,
    paddingHorizontal: Spacing.md,
    borderRadius: BorderRadius.full,
    backgroundColor: Colors.light.surface,
    borderWidth: 1,
    borderColor: Colors.light.border,
    gap: Spacing.xs,
  },
  siteButtonSelected: {
    backgroundColor: Colors.light.primary,
    borderColor: Colors.light.primary,
  },
  siteButtonPressed: {
    opacity: 0.7,
  },
  siteButtonText: {
    ...Typography.caption,
    color: Colors.light.text,
  },
  siteButtonTextSelected: {
    color: Colors.light.buttonText,
  },
  durationCard: {
    marginBottom: Spacing.lg,
  },
  durationRow: {
    flexDirection: "row",
    gap: Spacing.sm,
  },
  durationButton: {
    flex: 1,
    alignItems: "center",
    paddingVertical: Spacing.md,
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.light.surface,
    borderWidth: 1,
    borderColor: Colors.light.border,
  },
  durationButtonSelected: {
    backgroundColor: Colors.light.primary,
    borderColor: Colors.light.primary,
  },
  durationButtonPressed: {
    opacity: 0.7,
  },
  durationValue: {
    ...Typography.title,
    color: Colors.light.text,
  },
  durationValueSelected: {
    color: Colors.light.buttonText,
  },
  durationLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginTop: Spacing.xs,
  },
  durationLabelSelected: {
    color: Colors.light.buttonText,
    opacity: 0.9,
  },
  tipCard: {
    backgroundColor: Colors.light.accent + "20",
    borderWidth: 1,
    borderColor: Colors.light.accent + "40",
  },
  tipHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: Spacing.sm,
  },
  tipIconContainer: {
    width: 32,
    height: 32,
    borderRadius: BorderRadius.full,
    backgroundColor: Colors.light.surface,
    alignItems: "center",
    justifyContent: "center",
    marginRight: Spacing.sm,
  },
  tipTitle: {
    ...Typography.button,
    color: Colors.light.text,
    flex: 1,
  },
  tipText: {
    ...Typography.body,
    color: Colors.light.text,
  },
  fabContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    alignItems: "center",
  },
  fab: {
    borderRadius: BorderRadius.lg,
    ...Shadows.fab,
  },
  fabPressed: {
    opacity: 0.9,
    transform: [{ scale: 0.98 }],
  },
  fabGradient: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: Spacing.lg,
    paddingHorizontal: Spacing["2xl"],
    borderRadius: BorderRadius.lg,
  },
  fabText: {
    ...Typography.button,
    color: Colors.light.buttonText,
    marginLeft: Spacing.sm,
  },
});
-e 
========== FILE: ./client/screens/DiscoveryWizardScreen.tsx ==========
import React, { useState, useEffect } from "react";
import { View, StyleSheet, Pressable, Platform, ScrollView } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation, useRoute, RouteProp } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";
import Slider from "@react-native-community/slider";
import * as Haptics from "expo-haptics";
import { ThemedText } from "@/components/ThemedText";
import { Card } from "@/components/Card";
import { Button } from "@/components/Button";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";
import { HapticsService } from "@/services/HapticsService";
import type { RootStackParamList } from "@/navigation/RootStackNavigator";
import type { SessionSite, SiteTuning, PeakStyle } from "@/types";
import { SESSION_SITE_LABELS } from "@/types";

type NavigationProp = NativeStackNavigationProp<RootStackParamList>;
type DiscoveryRouteProp = RouteProp<RootStackParamList, 'DiscoveryWizard'>;

const SITES: SessionSite[] = [
  'arm-left', 'arm-right', 
  'thigh-left', 'thigh-right', 
  'abdomen-left', 'abdomen-right',
  'other'
];

type WizardStep = 'site-select' | 'trial-abc' | 'fine-tune' | 'audio' | 'complete';

interface TrialPreset {
  id: 'A' | 'B' | 'C';
  label: string;
  description: string;
  intensity: number;
  snapDensity: number;
  peakStyle: PeakStyle;
}

const TRIAL_PRESETS: TrialPreset[] = [
  {
    id: 'A',
    label: 'Gentle',
    description: 'Light, steady pulses with gradual peak',
    intensity: 0.4,
    snapDensity: 0.3,
    peakStyle: 'max',
  },
  {
    id: 'B',
    label: 'Balanced',
    description: 'Medium intensity with rhythmic snaps',
    intensity: 0.6,
    snapDensity: 0.5,
    peakStyle: 'snap',
  },
  {
    id: 'C',
    label: 'Strong',
    description: 'Firm, pronounced feedback throughout',
    intensity: 0.8,
    snapDensity: 0.7,
    peakStyle: 'max',
  },
];

export default function DiscoveryWizardScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<DiscoveryRouteProp>();
  const { preferences, saveSiteTuning, getSiteTuning, updatePreferences, onboarding } = useApp();

  const [step, setStep] = useState<WizardStep>('site-select');
  const [selectedSite, setSelectedSite] = useState<SessionSite | undefined>(route.params?.site);
  const [selectedTrial, setSelectedTrial] = useState<'A' | 'B' | 'C' | null>(null);
  
  const [hapticIntensity, setHapticIntensity] = useState(0.5);
  const [snapDensity, setSnapDensity] = useState(0.5);
  const [peakStyle, setPeakStyle] = useState<PeakStyle>('max');
  const [audioVolume, setAudioVolume] = useState(0.7);

  useEffect(() => {
    if (selectedSite) {
      const existingTuning = getSiteTuning(selectedSite);
      if (existingTuning) {
        setHapticIntensity(existingTuning.hapticIntensity);
        setSnapDensity(existingTuning.snapDensity);
        setPeakStyle(existingTuning.peakStyle);
        setAudioVolume(existingTuning.audioVolume);
      } else {
        setHapticIntensity(preferences.hapticIntensity);
        setSnapDensity(preferences.snapDensity);
        setPeakStyle(preferences.peakStyle);
        setAudioVolume(preferences.audioVolume);
      }
    }
  }, [selectedSite, getSiteTuning, preferences]);

  const handleSiteSelect = async (site: SessionSite) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setSelectedSite(site);
    setStep('trial-abc');
  };

  const handleTrialTest = async (preset: TrialPreset) => {
    HapticsService.setIntensity(preset.intensity);
    HapticsService.setSnapDensity(preset.snapDensity);
    HapticsService.setPeakStyle(preset.peakStyle);
    
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      await delay(100);
      await Haptics.impactAsync(preset.peakStyle === 'max' ? Haptics.ImpactFeedbackStyle.Heavy : Haptics.ImpactFeedbackStyle.Medium);
      await delay(80);
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      if (preset.snapDensity > 0.5) {
        await delay(60);
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      }
    }
  };

  const handleTrialSelect = async (trialId: 'A' | 'B' | 'C') => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setSelectedTrial(trialId);
    const preset = TRIAL_PRESETS.find(p => p.id === trialId);
    if (preset) {
      setHapticIntensity(preset.intensity);
      setSnapDensity(preset.snapDensity);
      setPeakStyle(preset.peakStyle);
    }
  };

  const handleTestCurrent = async () => {
    HapticsService.setIntensity(hapticIntensity);
    HapticsService.setSnapDensity(snapDensity);
    HapticsService.setPeakStyle(peakStyle);
    
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      await delay(100);
      await Haptics.impactAsync(peakStyle === 'max' ? Haptics.ImpactFeedbackStyle.Heavy : Haptics.ImpactFeedbackStyle.Medium);
      await delay(80);
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  const handleNext = () => {
    if (step === 'site-select' && !selectedSite) {
      return;
    }
    if (step === 'trial-abc' && !selectedTrial) {
      return;
    }
    const steps: WizardStep[] = ['site-select', 'trial-abc', 'fine-tune', 'audio', 'complete'];
    const currentIndex = steps.indexOf(step);
    if (currentIndex < steps.length - 1) {
      setStep(steps[currentIndex + 1]);
    }
  };

  const handleBack = () => {
    const steps: WizardStep[] = ['site-select', 'trial-abc', 'fine-tune', 'audio', 'complete'];
    const currentIndex = steps.indexOf(step);
    if (currentIndex > 0) {
      setStep(steps[currentIndex - 1]);
    }
  };

  const handleSave = async () => {
    if (!selectedSite) {
      return;
    }
    
    const tuning: SiteTuning = {
      hapticIntensity,
      snapDensity,
      peakStyle,
      audioVolume,
    };
    await saveSiteTuning(selectedSite, tuning);
    await updatePreferences({ discoveryCompleted: true });
    
    if (Platform.OS !== "web") {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
    navigation.goBack();
  };

  const renderSiteSelect = () => (
    <View style={styles.stepContent}>
      <ThemedText style={styles.stepTitle}>Choose a Site</ThemedText>
      <ThemedText style={styles.stepDescription}>
        Select where you'd like to tune your comfort settings
      </ThemedText>
      
      <View style={styles.siteGrid}>
        {SITES.map((site) => (
          <Pressable
            key={site}
            style={({ pressed }) => [
              styles.siteButton,
              selectedSite === site && styles.siteButtonSelected,
              pressed && styles.siteButtonPressed,
            ]}
            onPress={() => handleSiteSelect(site)}
            testID={`button-wizard-site-${site}`}
          >
            <Feather 
              name="circle" 
              size={18} 
              color={selectedSite === site ? Colors.light.buttonText : Colors.light.textSecondary} 
            />
            <ThemedText
              style={[
                styles.siteButtonText,
                selectedSite === site && styles.siteButtonTextSelected,
              ]}
            >
              {SESSION_SITE_LABELS[site]}
            </ThemedText>
          </Pressable>
        ))}
      </View>
    </View>
  );

  const renderTrialABC = () => (
    <View style={styles.stepContent}>
      <ThemedText style={styles.stepTitle}>Try These Options</ThemedText>
      <ThemedText style={styles.stepDescription}>
        Tap each option to feel it, then select your favorite
      </ThemedText>
      
      <View style={styles.trialsContainer}>
        {TRIAL_PRESETS.map((preset) => (
          <Card 
            key={preset.id} 
            style={[
              styles.trialCard,
              selectedTrial === preset.id && styles.trialCardSelected,
            ]}
          >
            <Pressable
              style={styles.trialContent}
              onPress={() => handleTrialSelect(preset.id)}
              testID={`button-trial-${preset.id}`}
            >
              <View style={styles.trialHeader}>
                <View style={[
                  styles.trialBadge,
                  selectedTrial === preset.id && styles.trialBadgeSelected,
                ]}>
                  <ThemedText style={[
                    styles.trialBadgeText,
                    selectedTrial === preset.id && styles.trialBadgeTextSelected,
                  ]}>
                    {preset.id}
                  </ThemedText>
                </View>
                <ThemedText style={styles.trialLabel}>{preset.label}</ThemedText>
                {selectedTrial === preset.id && (
                  <Feather name="check-circle" size={20} color={Colors.light.primary} />
                )}
              </View>
              <ThemedText style={styles.trialDescription}>{preset.description}</ThemedText>
              
              <Pressable
                style={({ pressed }) => [styles.tryButton, pressed && styles.tryButtonPressed]}
                onPress={() => handleTrialTest(preset)}
                testID={`button-try-${preset.id}`}
              >
                <Feather name="zap" size={16} color={Colors.light.primary} />
                <ThemedText style={styles.tryButtonText}>Try</ThemedText>
              </Pressable>
            </Pressable>
          </Card>
        ))}
      </View>
    </View>
  );

  const renderFineTune = () => (
    <View style={styles.stepContent}>
      <ThemedText style={styles.stepTitle}>Fine-Tune</ThemedText>
      <ThemedText style={styles.stepDescription}>
        Adjust settings based on your selection
      </ThemedText>
      
      <Card style={styles.tuningCard}>
        <ThemedText style={styles.tuningLabel}>Intensity</ThemedText>
        <View style={styles.sliderContainer}>
          <ThemedText style={styles.sliderLabel}>Gentle</ThemedText>
          <Slider
            style={styles.slider}
            minimumValue={0.1}
            maximumValue={1}
            value={hapticIntensity}
            onValueChange={setHapticIntensity}
            minimumTrackTintColor={Colors.light.primary}
            maximumTrackTintColor={Colors.light.border}
            thumbTintColor={Colors.light.primary}
            testID="slider-wizard-intensity"
          />
          <ThemedText style={styles.sliderLabel}>Strong</ThemedText>
        </View>

        <View style={styles.divider} />

        <ThemedText style={styles.tuningLabel}>Peak Style</ThemedText>
        <View style={styles.segmented}>
          <Pressable
            style={({ pressed }) => [
              styles.segButton,
              peakStyle === 'max' && styles.segButtonSelected,
              pressed && styles.segButtonPressed,
            ]}
            onPress={() => setPeakStyle('max')}
            testID="button-peak-max"
          >
            <ThemedText style={[styles.segButtonText, peakStyle === 'max' && styles.segButtonTextSelected]}>
              Max
            </ThemedText>
          </Pressable>
          <Pressable
            style={({ pressed }) => [
              styles.segButton,
              peakStyle === 'snap' && styles.segButtonSelected,
              pressed && styles.segButtonPressed,
            ]}
            onPress={() => setPeakStyle('snap')}
            testID="button-peak-snap"
          >
            <ThemedText style={[styles.segButtonText, peakStyle === 'snap' && styles.segButtonTextSelected]}>
              Snap
            </ThemedText>
          </Pressable>
        </View>

        {peakStyle === 'snap' && (
          <>
            <View style={styles.divider} />
            <ThemedText style={styles.tuningLabel}>Snap Frequency</ThemedText>
            <View style={styles.sliderContainer}>
              <ThemedText style={styles.sliderLabel}>2 Hz</ThemedText>
              <Slider
                style={styles.slider}
                minimumValue={0}
                maximumValue={1}
                value={snapDensity}
                onValueChange={setSnapDensity}
                minimumTrackTintColor={Colors.light.accent}
                maximumTrackTintColor={Colors.light.border}
                thumbTintColor={Colors.light.accent}
                testID="slider-wizard-snap"
              />
              <ThemedText style={styles.sliderLabel}>8 Hz</ThemedText>
            </View>
          </>
        )}

        <Pressable
          style={({ pressed }) => [styles.testButton, pressed && styles.testButtonPressed]}
          onPress={handleTestCurrent}
          testID="button-test-current"
        >
          <Feather name="zap" size={18} color={Colors.light.primary} />
          <ThemedText style={styles.testButtonText}>Test Current Settings</ThemedText>
        </Pressable>
      </Card>
    </View>
  );

  const renderAudioStep = () => (
    <View style={styles.stepContent}>
      <ThemedText style={styles.stepTitle}>Audio Volume</ThemedText>
      <ThemedText style={styles.stepDescription}>
        Set the background audio level for this site
      </ThemedText>
      
      <Card style={styles.tuningCard}>
        <View style={styles.sliderContainer}>
          <ThemedText style={styles.sliderLabel}>Low</ThemedText>
          <Slider
            style={styles.slider}
            minimumValue={0.1}
            maximumValue={1}
            value={audioVolume}
            onValueChange={setAudioVolume}
            minimumTrackTintColor={Colors.light.primary}
            maximumTrackTintColor={Colors.light.border}
            thumbTintColor={Colors.light.primary}
            testID="slider-wizard-audio"
          />
          <ThemedText style={styles.sliderLabel}>High</ThemedText>
        </View>
      </Card>
    </View>
  );

  const renderComplete = () => (
    <View style={styles.stepContent}>
      <View style={styles.completeIcon}>
        <Feather name="check-circle" size={64} color={Colors.light.success} />
      </View>
      <ThemedText style={styles.stepTitle}>All Set!</ThemedText>
      <ThemedText style={styles.stepDescription}>
        Your settings for {selectedSite ? SESSION_SITE_LABELS[selectedSite] : 'this site'} have been saved.
      </ThemedText>
      
      <Card style={styles.summaryCard}>
        <View style={styles.summaryRow}>
          <ThemedText style={styles.summaryLabel}>Intensity</ThemedText>
          <ThemedText style={styles.summaryValue}>{Math.round(hapticIntensity * 100)}%</ThemedText>
        </View>
        <View style={styles.summaryRow}>
          <ThemedText style={styles.summaryLabel}>Peak Style</ThemedText>
          <ThemedText style={styles.summaryValue}>{peakStyle === 'max' ? 'Max' : 'Snap'}</ThemedText>
        </View>
        {peakStyle === 'snap' && (
          <View style={styles.summaryRow}>
            <ThemedText style={styles.summaryLabel}>Snap Frequency</ThemedText>
            <ThemedText style={styles.summaryValue}>{Math.round(2 + snapDensity * 6)} Hz</ThemedText>
          </View>
        )}
        <View style={styles.summaryRow}>
          <ThemedText style={styles.summaryLabel}>Audio Volume</ThemedText>
          <ThemedText style={styles.summaryValue}>{Math.round(audioVolume * 100)}%</ThemedText>
        </View>
      </Card>
    </View>
  );

  const renderStep = () => {
    switch (step) {
      case 'site-select': return renderSiteSelect();
      case 'trial-abc': return renderTrialABC();
      case 'fine-tune': return renderFineTune();
      case 'audio': return renderAudioStep();
      case 'complete': return renderComplete();
    }
  };

  const getStepNumber = () => {
    const steps: WizardStep[] = ['site-select', 'trial-abc', 'fine-tune', 'audio', 'complete'];
    return steps.indexOf(step) + 1;
  };

  const canProceed = () => {
    if (step === 'site-select') return !!selectedSite;
    if (step === 'trial-abc') return !!selectedTrial;
    return true;
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <View style={styles.header}>
        <Pressable
          style={({ pressed }) => [styles.closeButton, pressed && styles.closeButtonPressed]}
          onPress={() => navigation.goBack()}
          testID="button-close-wizard"
        >
          <Feather name="x" size={24} color={Colors.light.text} />
        </Pressable>
        
        <View style={styles.progress}>
          {[1, 2, 3, 4, 5].map((num) => (
            <View 
              key={num} 
              style={[
                styles.progressDot,
                num <= getStepNumber() && styles.progressDotActive,
              ]} 
            />
          ))}
        </View>
      </View>

      <ScrollView 
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {renderStep()}
      </ScrollView>

      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing.lg }]}>
        {step !== 'site-select' && (
          <View style={styles.footerButtons}>
            {step !== 'complete' ? (
              <>
                <Button
                  title="Back"
                  onPress={handleBack}
                  variant="outline"
                  style={styles.footerButton}
                  testID="button-wizard-back"
                />
                <Button
                  title="Next"
                  onPress={handleNext}
                  disabled={!canProceed()}
                  style={styles.footerButton}
                  testID="button-wizard-next"
                />
              </>
            ) : (
              <Button
                title="Save & Close"
                onPress={handleSave}
                style={styles.footerButtonFull}
                testID="button-wizard-save"
              />
            )}
          </View>
        )}
      </View>
    </View>
  );
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: Spacing.lg,
    paddingVertical: Spacing.md,
  },
  closeButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: Colors.light.surface,
    alignItems: "center",
    justifyContent: "center",
  },
  closeButtonPressed: {
    opacity: 0.7,
  },
  progress: {
    flex: 1,
    flexDirection: "row",
    justifyContent: "center",
    gap: Spacing.sm,
  },
  progressDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: Colors.light.border,
  },
  progressDotActive: {
    backgroundColor: Colors.light.primary,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingHorizontal: Spacing.xl,
    paddingBottom: Spacing["2xl"],
  },
  stepContent: {
    flex: 1,
  },
  stepTitle: {
    ...Typography.headline,
    color: Colors.light.text,
    textAlign: "center",
    marginBottom: Spacing.sm,
  },
  stepDescription: {
    ...Typography.body,
    color: Colors.light.textSecondary,
    textAlign: "center",
    marginBottom: Spacing["2xl"],
  },
  siteGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: Spacing.sm,
    justifyContent: "center",
  },
  siteButton: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: Spacing.md,
    paddingHorizontal: Spacing.lg,
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.light.surface,
    borderWidth: 1,
    borderColor: Colors.light.border,
    gap: Spacing.sm,
    minWidth: 140,
  },
  siteButtonSelected: {
    backgroundColor: Colors.light.primary,
    borderColor: Colors.light.primary,
  },
  siteButtonPressed: {
    opacity: 0.7,
  },
  siteButtonText: {
    ...Typography.body,
    color: Colors.light.text,
  },
  siteButtonTextSelected: {
    color: Colors.light.buttonText,
  },
  trialsContainer: {
    gap: Spacing.md,
  },
  trialCard: {
    borderWidth: 2,
    borderColor: "transparent",
  },
  trialCardSelected: {
    borderColor: Colors.light.primary,
  },
  trialContent: {
    padding: Spacing.md,
  },
  trialHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: Spacing.sm,
    marginBottom: Spacing.xs,
  },
  trialBadge: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: Colors.light.border,
    alignItems: "center",
    justifyContent: "center",
  },
  trialBadgeSelected: {
    backgroundColor: Colors.light.primary,
  },
  trialBadgeText: {
    ...Typography.button,
    color: Colors.light.text,
    fontSize: 14,
  },
  trialBadgeTextSelected: {
    color: Colors.light.buttonText,
  },
  trialLabel: {
    ...Typography.button,
    color: Colors.light.text,
    flex: 1,
  },
  trialDescription: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginBottom: Spacing.sm,
  },
  tryButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: Spacing.sm,
    borderRadius: BorderRadius.sm,
    backgroundColor: Colors.light.primary + "15",
    gap: Spacing.xs,
  },
  tryButtonPressed: {
    opacity: 0.7,
  },
  tryButtonText: {
    ...Typography.caption,
    color: Colors.light.primary,
    fontWeight: "600",
  },
  tuningCard: {
    padding: Spacing.xl,
  },
  tuningLabel: {
    ...Typography.button,
    color: Colors.light.text,
    marginBottom: Spacing.sm,
  },
  sliderContainer: {
    flexDirection: "row",
    alignItems: "center",
  },
  slider: {
    flex: 1,
    height: 40,
  },
  sliderLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    width: 50,
    textAlign: "center",
  },
  divider: {
    height: 1,
    backgroundColor: Colors.light.border,
    marginVertical: Spacing.lg,
  },
  segmented: {
    flexDirection: "row",
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.lg,
    borderWidth: 1,
    borderColor: Colors.light.border,
    overflow: "hidden",
  },
  segButton: {
    flex: 1,
    paddingVertical: Spacing.md,
    alignItems: "center",
  },
  segButtonSelected: {
    backgroundColor: Colors.light.primary,
  },
  segButtonPressed: {
    opacity: 0.85,
  },
  segButtonText: {
    ...Typography.button,
    color: Colors.light.text,
  },
  segButtonTextSelected: {
    color: Colors.light.buttonText,
  },
  testButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: Spacing.md,
    marginTop: Spacing.lg,
    borderRadius: BorderRadius.md,
    backgroundColor: Colors.light.primary + "15",
    gap: Spacing.sm,
  },
  testButtonPressed: {
    opacity: 0.7,
  },
  testButtonText: {
    ...Typography.button,
    color: Colors.light.primary,
  },
  completeIcon: {
    alignItems: "center",
    marginBottom: Spacing.xl,
  },
  summaryCard: {
    marginTop: Spacing.lg,
  },
  summaryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingVertical: Spacing.sm,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.border + "50",
  },
  summaryLabel: {
    ...Typography.body,
    color: Colors.light.textSecondary,
  },
  summaryValue: {
    ...Typography.button,
    color: Colors.light.text,
  },
  footer: {
    paddingHorizontal: Spacing.xl,
  },
  footerButtons: {
    flexDirection: "row",
    gap: Spacing.md,
  },
  footerButton: {
    flex: 1,
  },
  footerButtonFull: {
    flex: 1,
  },
});
-e 
========== FILE: ./client/screens/SessionScreen.tsx ==========
// client/screens/SessionScreen.tsx
import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { View, StyleSheet, Pressable, Alert, Animated } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation, useRoute, RouteProp } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";
import { LinearGradient } from "expo-linear-gradient";
import { activateKeepAwakeAsync, deactivateKeepAwake } from "expo-keep-awake";

import { ThemedText } from "@/components/ThemedText";
import { DragonflyFlight } from "@/components/DragonflyFlight";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { sensoryService } from "@/services/SensoryService";
import { useSessionAudio } from "@/hooks/useSessionAudio";
import { useApp } from "@/context/AppContext";

import type { RootStackParamList } from "@/navigation/RootStackNavigator";
import type { HapticPattern } from "@/types";
import { SESSION_PHASE_PRESETS } from "@/types";

type NavigationProp = NativeStackNavigationProp<RootStackParamList>;
type SessionRouteProp = RouteProp<RootStackParamList, "Session">;

type SessionPhase = "idle" | "settle" | "peak" | "cool" | "complete";

function clamp01(x: number) {
  return Math.max(0, Math.min(1, x));
}

function lerp(a: number, b: number, t: number) {
  return a + (b - a) * t;
}

export default function SessionScreen() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<SessionRouteProp>();
  const { preferences, getSiteTuning } = useApp();

  const site = route.params?.site;
  const duration = route.params?.duration || preferences.selectedDuration || 24;

  const phases = SESSION_PHASE_PRESETS[duration];
  const totalDuration = phases.settle + phases.peak + phases.cool;

  const siteTuning = site ? getSiteTuning(site) : undefined;

  const effectiveIntensity =
    siteTuning?.hapticIntensity ?? preferences.hapticIntensity;
  const effectiveSnapDensity =
    siteTuning?.snapDensity ?? preferences.snapDensity;
  const effectivePeakStyle = siteTuning?.peakStyle ?? preferences.peakStyle;
  const effectiveAudioVolume =
    siteTuning?.audioVolume ?? preferences.audioVolume;

  const [isRunning, setIsRunning] = useState(false);
  const [timeElapsed, setTimeElapsed] = useState(0);
  const [currentPhase, setCurrentPhase] = useState<SessionPhase>("idle");
  const [selectedPattern, setSelectedPattern] =
    useState<HapticPattern>("standard");

  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);

  // Subtle UI animation refs
  const aliAnim = useRef(new Animated.Value(0)).current;
  const pulseAnim = useRef(new Animated.Value(1)).current;

  // Music position for animation sync
  const [musicPositionMs, setMusicPositionMs] = useState(0);

  const { playStartSound, playCompleteSound } = useSessionAudio(
    preferences.audioEnabled,
  );

  // Poll music position while running (10 Hz)
  useEffect(() => {
    if (!isRunning) return;

    let cancelled = false;

    const id = setInterval(async () => {
      try {
        const ms = await sensoryService.getMusicPositionMs();
        if (!cancelled) setMusicPositionMs(ms);
      } catch {
        // ignore
      }
    }, 100);

    return () => {
      cancelled = true;
      clearInterval(id);
    };
  }, [isRunning]);

  // Determine session phase from elapsed time
  useEffect(() => {
    if (!isRunning) {
      setCurrentPhase("idle");
      return;
    }

    if (timeElapsed < phases.settle) setCurrentPhase("settle");
    else if (timeElapsed < phases.settle + phases.peak) setCurrentPhase("peak");
    else if (timeElapsed < totalDuration) setCurrentPhase("cool");
    else setCurrentPhase("complete");
  }, [isRunning, timeElapsed, phases, totalDuration]);

  // Auto-end when complete
  useEffect(() => {
    if (currentPhase === "complete" && isRunning) {
      void handleEndSession();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentPhase, isRunning]);

  // Inform haptics engine when phase changes
  useEffect(() => {
    if (!isRunning) return;
    if (currentPhase === "idle" || currentPhase === "complete") return;

    sensoryService.updatePhase(
      currentPhase === "cool" ? "coolDown" : currentPhase,
    );
  }, [currentPhase, isRunning]);

  // Background UI animations + cleanup
  useEffect(() => {
    const a1 = Animated.loop(
      Animated.sequence([
        Animated.timing(aliAnim, {
          toValue: 1,
          duration: 3000,
          useNativeDriver: true,
        }),
        Animated.timing(aliAnim, {
          toValue: 0,
          duration: 3000,
          useNativeDriver: true,
        }),
      ]),
    );

    const a2 = Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, {
          toValue: 1.05,
          duration: 1500,
          useNativeDriver: true,
        }),
        Animated.timing(pulseAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        }),
      ]),
    );

    a1.start();
    a2.start();

    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
      try {
        deactivateKeepAwake();
      } catch {}
      void sensoryService.stop();
      a1.stop();
      a2.stop();
    };
  }, [aliAnim, pulseAnim]);

  // -----------------------
  // Dragonfly alignment logic (12/6/6 and beat-locked)
  // -----------------------
  const beatBpm = 80;
  const beatPeriodMs = 60000 / beatBpm;

  const phaseProgress01 = useMemo(() => {
    if (!isRunning) return 0;
    if (currentPhase === "settle") return clamp01(timeElapsed / phases.settle);
    if (currentPhase === "peak")
      return clamp01((timeElapsed - phases.settle) / phases.peak);
    if (currentPhase === "cool")
      return clamp01((timeElapsed - phases.settle - phases.peak) / phases.cool);
    return 0;
  }, [isRunning, currentPhase, timeElapsed, phases]);

  const dragonflyPhase = useMemo(() => {
    if (currentPhase === "settle") return "settle";
    if (currentPhase === "peak") return "peak";
    if (currentPhase === "cool") return "cool";
    return "idle";
  }, [currentPhase]);

  const beatPhase01 = useMemo(() => {
    if (!musicPositionMs) return 0;
    return (musicPositionMs % beatPeriodMs) / beatPeriodMs;
  }, [musicPositionMs, beatPeriodMs]);

  const dragonflyIntensity01 = useMemo(() => {
    const user = clamp01(effectiveIntensity);

    if (!isRunning) return 0.15;

    if (currentPhase === "settle") {
      // 12s ramp: 0.35 -> 0.75 (scaled by user)
      const base = lerp(0.35, 0.75, phaseProgress01);
      return clamp01(base * (0.75 + 0.35 * user));
    }

    if (currentPhase === "peak") {
      // 6s urgent: hover near 0.95 with beat-locked tremor
      const tremor = 0.06 * Math.sin(Math.PI * 2 * beatPhase01);
      const base = 0.92 + tremor;
      return clamp01(base * (0.8 + 0.3 * user));
    }

    if (currentPhase === "cool") {
      // 6s decay: 0.70 -> 0.30
      const base = lerp(0.7, 0.3, phaseProgress01);
      return clamp01(base * (0.85 + 0.25 * user));
    }

    return 0.2;
  }, [
    isRunning,
    currentPhase,
    phaseProgress01,
    beatPhase01,
    effectiveIntensity,
  ]);

  const dragonflyCarrierDensity = useMemo(() => {
    const patternBase =
      selectedPattern === "standard"
        ? 26
        : selectedPattern === "gentle-wave"
          ? 18
          : 22;

    const user = clamp01(effectiveIntensity);
    const snap = clamp01(effectiveSnapDensity);

    const phaseMul =
      currentPhase === "peak"
        ? 1.25
        : currentPhase === "settle"
          ? 1.0
          : currentPhase === "cool"
            ? 0.85
            : 0.8;

    const snapMul = 0.85 + 0.55 * snap;
    const intMul = 0.75 + 0.55 * user;

    return patternBase * phaseMul * snapMul * intMul;
  }, [selectedPattern, currentPhase, effectiveIntensity, effectiveSnapDensity]);

  // -------------
  // Session handlers
  // -------------
  const startSession = useCallback(async () => {
    try {
      await activateKeepAwakeAsync();
    } catch {
      console.log("Keep awake not available");
    }

    setIsRunning(true);
    setTimeElapsed(0);
    setCurrentPhase("settle");

    if (preferences.audioEnabled) {
      await playStartSound();
    }

    await sensoryService.startSession({
      pattern: selectedPattern,
      phase: "settle",
      audioEnabled: preferences.audioEnabled,
      hapticsIntensity01: effectiveIntensity,
      audioVolume01: effectiveAudioVolume,
      peakStyle: effectivePeakStyle,
      snapDensity01: effectiveSnapDensity,
      useAdvancedHaptics: !!preferences.useAdvancedHaptics,
    });

    timerRef.current = setInterval(() => {
      setTimeElapsed((prev) => prev + 1);
    }, 1000);
  }, [
    selectedPattern,
    preferences.audioEnabled,
    preferences.useAdvancedHaptics,
    playStartSound,
    effectiveIntensity,
    effectiveAudioVolume,
    effectivePeakStyle,
    effectiveSnapDensity,
  ]);

  const stopSession = useCallback(async () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    await sensoryService.stop();
    setIsRunning(false);

    try {
      deactivateKeepAwake();
    } catch {}

    if (preferences.audioEnabled) {
      await playCompleteSound();
    }
  }, [preferences.audioEnabled, playCompleteSound]);

  const handleEndSession = useCallback(async () => {
    await stopSession();
    navigation.replace("ComfortRating", {
      duration: timeElapsed,
      hapticPattern: selectedPattern,
      site,
    });
  }, [stopSession, navigation, timeElapsed, selectedPattern, site]);

  const handleClose = useCallback(() => {
    if (isRunning || timeElapsed > 0) {
      Alert.alert(
        "End Session?",
        "Your progress will be saved. Are you sure you want to end this session?",
        [
          { text: "Continue", style: "cancel" },
          { text: "End Session", onPress: () => void handleEndSession() },
        ],
      );
    } else {
      navigation.goBack();
    }
  }, [isRunning, timeElapsed, handleEndSession, navigation]);

  // -------------
  // UI
  // -------------
  const dragonflyVariant = preferences.dragonflyVariant ?? "blue";

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <LinearGradient
        colors={[Colors.bgTop, Colors.bgBottom]}
        style={StyleSheet.absoluteFill}
      />

      <Pressable onPress={handleClose} style={styles.closeBtn}>
        <Feather name="x" size={22} color={Colors.text} />
      </Pressable>

      <View style={styles.header}>
        <ThemedText style={styles.title}>Session</ThemedText>
        <ThemedText style={styles.subtitle}>
          {isRunning
            ? `${timeElapsed}s / ${totalDuration}s`
            : `${totalDuration}s`}
        </ThemedText>
      </View>

      <View style={styles.stage}>
        <Animated.View style={{ transform: [{ scale: pulseAnim }] }}>
          <View style={styles.orb} />
        </Animated.View>

        <DragonflyFlight
          variant={dragonflyVariant}
          // DragonflyFlight prop type expects "idle|settle|peak|cool"
          phase={dragonflyPhase as any}
          intensity={dragonflyIntensity01}
          carrierDensity={dragonflyCarrierDensity}
          musicPositionMs={musicPositionMs}
        />
      </View>

      <View style={styles.controls}>
        <Pressable
          onPress={
            isRunning
              ? () => void handleEndSession()
              : () => void startSession()
          }
          style={({ pressed }) => [
            styles.primaryBtn,
            pressed && { opacity: 0.8 },
          ]}
        >
          <ThemedText style={styles.primaryBtnText}>
            {isRunning ? "End" : "Start"}
          </ThemedText>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1 },

  closeBtn: {
    position: "absolute",
    top: 14,
    right: 14,
    zIndex: 10,
    padding: 10,
  },

  header: {
    paddingHorizontal: Spacing.lg,
    paddingTop: 12,
    paddingBottom: 10,
  },

  title: {
    fontSize: Typography.h1,
    color: Colors.text,
    fontWeight: "700",
  },

  subtitle: {
    marginTop: 4,
    fontSize: Typography.body,
    color: Colors.muted,
  },

  stage: {
    flex: 1,
    marginHorizontal: Spacing.lg,
    borderRadius: BorderRadius.xl,
    overflow: "hidden",
    justifyContent: "center",
    alignItems: "center",
  },

  orb: {
    width: 180,
    height: 180,
    borderRadius: 90,
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.12)",
  },

  controls: {
    paddingHorizontal: Spacing.lg,
    paddingBottom: Spacing.lg,
  },

  primaryBtn: {
    height: 54,
    borderRadius: 16,
    backgroundColor: "rgba(255,255,255,0.14)",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.20)",
    alignItems: "center",
    justifyContent: "center",
  },

  primaryBtnText: {
    color: Colors.text,
    fontSize: 18,
    fontWeight: "700",
  },
});
-e 
========== FILE: ./client/screens/SettingsScreen.tsx ==========
import React, { useState } from "react";
import {
  View,
  StyleSheet,
  Pressable,
  Switch,
  Alert,
  Platform,
} from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useBottomTabBarHeight } from "@react-navigation/bottom-tabs";
import { useNavigation } from "@react-navigation/native";
import type { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { Feather } from "@expo/vector-icons";

import Slider from "@react-native-community/slider";
import * as Haptics from "expo-haptics";
import { KeyboardAwareScrollViewCompat } from "@/components/KeyboardAwareScrollViewCompat";
import { ThemedText } from "@/components/ThemedText";
import { Card } from "@/components/Card";
import { Colors, Spacing, BorderRadius, Typography } from "@/constants/theme";
import { useApp } from "@/context/AppContext";
import type { RootStackParamList } from "@/navigation/RootStackNavigator";
import type { PeakStyle } from "@/types";

type NavigationProp = NativeStackNavigationProp<RootStackParamList>;

export default function SettingsScreen() {
  const insets = useSafeAreaInsets();
  const tabBarHeight = useBottomTabBarHeight();
  const navigation = useNavigation<NavigationProp>();
  const { preferences, updatePreferences, clearSessions, resetApp } = useApp();
  const [hapticIntensity, setHapticIntensity] = useState(
    preferences.hapticIntensity,
  );
  const [audioVolume, setAudioVolume] = useState(
    preferences.audioVolume ?? 0.7,
  );
  const [snapDensity, setSnapDensity] = useState(
    preferences.snapDensity ?? 0.5,
  );

  const handleHapticSliderChange = async (value: number) => {
    setHapticIntensity(value);
  };

  const handleHapticSliderComplete = async (value: number) => {
    await updatePreferences({ hapticIntensity: value });
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  const handleAudioVolumeChange = async (value: number) => {
    setAudioVolume(value);
  };

  const handleAudioVolumeComplete = async (value: number) => {
    await updatePreferences({ audioVolume: value });
  };

  const handleSnapDensityChange = async (value: number) => {
    setSnapDensity(value);
  };

  const handleSnapDensityComplete = async (value: number) => {
    await updatePreferences({ snapDensity: value });
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  const handleAudioToggle = async (value: boolean) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    await updatePreferences({ audioEnabled: value });
  };

  const handleDebugToggle = async (value: boolean) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    await updatePreferences({ debugMode: value });
  };

  const handlePeakStyleChange = async (style: PeakStyle) => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    await updatePreferences({ peakStyle: style });
  };

  const handleOpenDiscovery = () => {
    navigation.navigate("DiscoveryWizard", {});
  };

  const handleClearHistory = () => {
    Alert.alert(
      "Clear History",
      "Are you sure you want to clear all session history? This cannot be undone.",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Clear",
          style: "destructive",
          onPress: async () => {
            await clearSessions();
            if (Platform.OS !== "web") {
              await Haptics.notificationAsync(
                Haptics.NotificationFeedbackType.Success,
              );
            }
          },
        },
      ],
    );
  };

  const handleResetApp = () => {
    Alert.alert(
      "Reset App",
      "This will clear all data and restart the onboarding. Are you sure?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Reset",
          style: "destructive",
          onPress: () => {
            Alert.alert(
              "Confirm Reset",
              "This action cannot be undone. All your data will be lost.",
              [
                { text: "Cancel", style: "cancel" },
                {
                  text: "Yes, Reset Everything",
                  style: "destructive",
                  onPress: async () => {
                    await resetApp();
                  },
                },
              ],
            );
          },
        },
      ],
    );
  };

  return (
    <KeyboardAwareScrollViewCompat
      style={styles.container}
      contentContainerStyle={[
        styles.scrollContent,
        {
          paddingTop: insets.top + Spacing["3xl"],
          paddingBottom: tabBarHeight + Spacing["2xl"],
        },
      ]}
    >
      <ThemedText style={styles.title}>Settings</ThemedText>

      <ThemedText style={styles.sectionTitle}>Haptic Preferences</ThemedText>
      <Card style={styles.card}>
        <View style={styles.settingRow}>
          <ThemedText style={styles.settingLabel}>Haptic Intensity</ThemedText>
        </View>
        <View style={styles.sliderContainer}>
          <ThemedText style={styles.sliderLabel}>Gentle</ThemedText>
          <Slider
            style={styles.slider}
            minimumValue={0.1}
            maximumValue={1}
            value={hapticIntensity}
            onValueChange={handleHapticSliderChange}
            onSlidingComplete={handleHapticSliderComplete}
            minimumTrackTintColor={Colors.light.primary}
            maximumTrackTintColor={Colors.light.border}
            thumbTintColor={Colors.light.primary}
            testID="slider-haptic"
          />
          <ThemedText style={styles.sliderLabel}>Strong</ThemedText>
        </View>

        <View style={styles.divider} />

        <View style={styles.settingRow}>
          <View style={styles.settingInfo}>
            <ThemedText style={styles.settingLabel}>Peak Style</ThemedText>
            <ThemedText style={styles.settingDescription}>
              How haptics behave during peak phase
            </ThemedText>
          </View>
        </View>
        <View style={styles.segmented}>
          <Pressable
            style={({ pressed }) => [
              styles.segButton,
              preferences.peakStyle === "max" && styles.segButtonSelected,
              pressed && styles.segButtonPressed,
            ]}
            onPress={() => handlePeakStyleChange("max")}
            testID="button-peak-max"
          >
            <ThemedText
              style={[
                styles.segButtonText,
                preferences.peakStyle === "max" && styles.segButtonTextSelected,
              ]}
            >
              Max
            </ThemedText>
          </Pressable>
          <Pressable
            style={({ pressed }) => [
              styles.segButton,
              preferences.peakStyle === "snap" && styles.segButtonSelected,
              pressed && styles.segButtonPressed,
            ]}
            onPress={() => handlePeakStyleChange("snap")}
            testID="button-peak-snap"
          >
            <ThemedText
              style={[
                styles.segButtonText,
                preferences.peakStyle === "snap" &&
                  styles.segButtonTextSelected,
              ]}
            >
              Snap
            </ThemedText>
          </Pressable>
        </View>

        {preferences.peakStyle === "snap" && (
          <>
            <View style={styles.divider} />

            <View style={styles.settingRow}>
              <ThemedText style={styles.settingLabel}>Snap Density</ThemedText>
              <ThemedText style={styles.settingDescription}>
                Controls frequency during peak (2-8 Hz)
              </ThemedText>
            </View>
            <View style={styles.sliderContainer}>
              <ThemedText style={styles.sliderLabel}>Sparse</ThemedText>
              <Slider
                style={styles.slider}
                minimumValue={0.1}
                maximumValue={1}
                value={snapDensity}
                onValueChange={handleSnapDensityChange}
                onSlidingComplete={handleSnapDensityComplete}
                minimumTrackTintColor={Colors.light.accent}
                maximumTrackTintColor={Colors.light.border}
                thumbTintColor={Colors.light.accent}
                testID="slider-snap-density"
              />
              <ThemedText style={styles.sliderLabel}>Dense</ThemedText>
            </View>
          </>
        )}
      </Card>
      {/* Advanced haptics feature flag (leave OFF by default) */}
      <View style={styles.settingRow}>
        <ThemedText style={styles.settingLabel}>
          Advanced Haptics (Dev Build)
        </ThemedText>
        <Switch
          value={!!preferences.useAdvancedHaptics}
          onValueChange={(v) => updatePreferences({ useAdvancedHaptics: v })}
        />
      </View>

      {/* Peak style */}
      <View style={styles.settingRow}>
        <ThemedText style={styles.settingLabel}>Peak Style</ThemedText>
        <View style={{ flexDirection: "row", gap: 10 }}>
          <Pressable
            style={[
              styles.pill,
              preferences.peakStyle !== "snap" && styles.pillActive,
            ]}
            onPress={() => updatePreferences({ peakStyle: "max" })}
          >
            <ThemedText>Max</ThemedText>
          </Pressable>

          <Pressable
            style={[
              styles.pill,
              preferences.peakStyle === "snap" && styles.pillActive,
            ]}
            onPress={() => updatePreferences({ peakStyle: "snap" })}
          >
            <ThemedText>Snap</ThemedText>
          </Pressable>
        </View>
      </View>

      {/* Snap density slider (only when Snap selected) */}
      {preferences.peakStyle === "snap" && (
        <View style={styles.settingBlock}>
          <ThemedText style={styles.settingLabel}>Snap Density</ThemedText>
          <Slider
            value={preferences.snapDensity01 ?? 0.5}
            minimumValue={0.15}
            maximumValue={1.0}
            step={0.01}
            onValueChange={(v) => updatePreferences({ snapDensity01: v })}
          />
        </View>
      )}

      {/* Haptics intensity */}
      <View style={styles.settingBlock}>
        <ThemedText style={styles.settingLabel}>Haptics Intensity</ThemedText>
        <Slider
          value={preferences.hapticsIntensity01 ?? 0.85}
          minimumValue={0.2}
          maximumValue={1.0}
          step={0.01}
          onValueChange={(v) => updatePreferences({ hapticsIntensity01: v })}
        />
      </View>

      {/* Audio volume */}
      <View style={styles.settingBlock}>
        <ThemedText style={styles.settingLabel}>Audio Volume</ThemedText>
        <Slider
          value={preferences.audioVolume01 ?? 0.6}
          minimumValue={0.0}
          maximumValue={1.0}
          step={0.01}
          onValueChange={(v) => updatePreferences({ audioVolume01: v })}
        />
      </View>

      <ThemedText style={styles.sectionTitle}>Audio Preferences</ThemedText>
      <Card style={styles.card}>
        <View style={styles.settingRow}>
          <View style={styles.settingInfo}>
            <ThemedText style={styles.settingLabel}>Sound Effects</ThemedText>
            <ThemedText style={styles.settingDescription}>
              Play calming sounds during sessions
            </ThemedText>
          </View>
          <Switch
            value={preferences.audioEnabled}
            onValueChange={handleAudioToggle}
            trackColor={{
              false: Colors.light.border,
              true: Colors.light.accent,
            }}
            thumbColor={Colors.light.surface}
            testID="switch-audio"
          />
        </View>

        {preferences.audioEnabled && (
          <>
            <View style={styles.divider} />
            <View style={styles.settingRow}>
              <ThemedText style={styles.settingLabel}>Audio Volume</ThemedText>
            </View>
            <View style={styles.sliderContainer}>
              <ThemedText style={styles.sliderLabel}>Low</ThemedText>
              <Slider
                style={styles.slider}
                minimumValue={0.1}
                maximumValue={1}
                value={audioVolume}
                onValueChange={handleAudioVolumeChange}
                onSlidingComplete={handleAudioVolumeComplete}
                minimumTrackTintColor={Colors.light.primary}
                maximumTrackTintColor={Colors.light.border}
                thumbTintColor={Colors.light.primary}
                testID="slider-audio-volume"
              />
              <ThemedText style={styles.sliderLabel}>High</ThemedText>
            </View>
          </>
        )}
      </Card>

      <ThemedText style={styles.sectionTitle}>Visual Preferences</ThemedText>
      <Card style={styles.card}>
        <View style={styles.settingRow}>
          <View style={styles.settingText}>
            <ThemedText style={styles.settingLabel}>Dragonfly</ThemedText>
            <ThemedText style={styles.settingDescription}>
              Choose your dragonfly style for sessions
            </ThemedText>
          </View>
          <View style={styles.segmented}>
            <Pressable
              style={({ pressed }) => [
                styles.segButton,
                preferences.dragonflyVariant === "blue" &&
                  styles.segButtonSelected,
                pressed && styles.segButtonPressed,
              ]}
              onPress={() => updatePreferences({ dragonflyVariant: "blue" })}
              testID="button-dragonfly-blue"
            >
              <ThemedText
                style={[
                  styles.segButtonText,
                  preferences.dragonflyVariant === "blue" &&
                    styles.segButtonTextSelected,
                ]}
              >
                Blue
              </ThemedText>
            </Pressable>
            <Pressable
              style={({ pressed }) => [
                styles.segButton,
                preferences.dragonflyVariant === "white" &&
                  styles.segButtonSelected,
                pressed && styles.segButtonPressed,
              ]}
              onPress={() => updatePreferences({ dragonflyVariant: "white" })}
              testID="button-dragonfly-white"
            >
              <ThemedText
                style={[
                  styles.segButtonText,
                  preferences.dragonflyVariant === "white" &&
                    styles.segButtonTextSelected,
                ]}
              >
                White
              </ThemedText>
            </Pressable>
          </View>
        </View>
      </Card>

      <ThemedText style={styles.sectionTitle}>Tuning</ThemedText>
      <Card style={styles.card}>
        <Pressable
          style={({ pressed }) => [
            styles.menuItem,
            pressed && styles.menuItemPressed,
          ]}
          onPress={handleOpenDiscovery}
          testID="button-discovery-wizard"
        >
          <Feather name="sliders" size={20} color={Colors.light.primary} />
          <ThemedText style={styles.menuItemText}>Discovery Wizard</ThemedText>
          <Feather
            name="chevron-right"
            size={20}
            color={Colors.light.textSecondary}
          />
        </Pressable>
        <ThemedText style={styles.menuItemDescription}>
          Fine-tune settings for each site
        </ThemedText>
      </Card>

      {preferences.debugMode && (
        <>
          <ThemedText style={styles.sectionTitle}>Developer</ThemedText>
          <Card style={styles.card}>
            <View style={styles.settingRow}>
              <View style={styles.settingInfo}>
                <ThemedText style={styles.settingLabel}>Debug Mode</ThemedText>
                <ThemedText style={styles.settingDescription}>
                  Show technical information during sessions
                </ThemedText>
              </View>
              <Switch
                value={preferences.debugMode}
                onValueChange={handleDebugToggle}
                trackColor={{
                  false: Colors.light.border,
                  true: Colors.light.accent,
                }}
                thumbColor={Colors.light.surface}
                testID="switch-debug"
              />
            </View>
          </Card>
        </>
      )}

      <ThemedText style={styles.sectionTitle}>Information</ThemedText>
      <Card style={styles.card}>
        <Pressable
          style={({ pressed }) => [
            styles.menuItem,
            pressed && styles.menuItemPressed,
          ]}
          onPress={() => navigation.navigate("About")}
          testID="button-about"
        >
          <Feather name="info" size={20} color={Colors.light.textSecondary} />
          <ThemedText style={styles.menuItemText}>About Alivio Ease</ThemedText>
          <Feather
            name="chevron-right"
            size={20}
            color={Colors.light.textSecondary}
          />
        </Pressable>

        <View style={styles.divider} />

        <Pressable
          style={({ pressed }) => [
            styles.menuItem,
            pressed && styles.menuItemPressed,
          ]}
          onPress={() => navigation.navigate("DisclaimerModal")}
          testID="button-disclaimer"
        >
          <Feather
            name="file-text"
            size={20}
            color={Colors.light.textSecondary}
          />
          <ThemedText style={styles.menuItemText}>View Disclaimer</ThemedText>
          <Feather
            name="chevron-right"
            size={20}
            color={Colors.light.textSecondary}
          />
        </Pressable>
      </Card>

      <ThemedText style={styles.sectionTitle}>Account</ThemedText>
      <Card style={styles.card}>
        <Pressable
          style={({ pressed }) => [
            styles.menuItem,
            pressed && styles.menuItemPressed,
          ]}
          onPress={handleClearHistory}
          testID="button-clear-history"
        >
          <Feather name="trash-2" size={20} color={Colors.light.warning} />
          <ThemedText style={[styles.menuItemText, styles.warningText]}>
            Clear History
          </ThemedText>
        </Pressable>

        <View style={styles.divider} />

        <Pressable
          style={({ pressed }) => [
            styles.menuItem,
            pressed && styles.menuItemPressed,
          ]}
          onPress={handleResetApp}
          testID="button-reset-app"
        >
          <Feather name="refresh-cw" size={20} color="#E74C3C" />
          <ThemedText style={[styles.menuItemText, styles.dangerText]}>
            Reset App
          </ThemedText>
        </Pressable>
      </Card>

      <Pressable
        onLongPress={handleDebugToggle.bind(null, !preferences.debugMode)}
        delayLongPress={3000}
        testID="version-text"
      >
        <ThemedText style={styles.version}>Alivio Ease v0.15</ThemedText>
      </Pressable>
    </KeyboardAwareScrollViewCompat>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  scrollContent: {
    paddingHorizontal: Spacing.xl,
  },
  title: {
    ...Typography.headline,
    color: Colors.light.text,
    marginBottom: Spacing.xl,
  },
  sectionTitle: {
    ...Typography.button,
    color: Colors.light.textSecondary,
    marginBottom: Spacing.sm,
    marginLeft: Spacing.xs,
  },
  card: {
    marginBottom: Spacing.xl,
  },
  settingRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  settingInfo: {
    flex: 1,
  },
  settingText: {
    flex: 1,
  },
  settingLabel: {
    ...Typography.body,
    color: Colors.light.text,
  },
  settingDescription: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginTop: Spacing.xs,
  },
  sliderContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: Spacing.sm,
  },
  slider: {
    flex: 1,
    height: 40,
  },
  sliderLabel: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    width: 50,
    textAlign: "center",
  },
  divider: {
    height: 1,
    backgroundColor: Colors.light.border,
    marginVertical: Spacing.lg,
    opacity: 0.6,
  },
  segmented: {
    flexDirection: "row",
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.lg,
    borderWidth: 1,
    borderColor: Colors.light.border,
    overflow: "hidden",
    marginTop: Spacing.sm,
  },
  segButton: {
    paddingHorizontal: Spacing.lg,
    paddingVertical: Spacing.md,
    backgroundColor: "transparent",
  },
  segButtonSelected: {
    backgroundColor: Colors.light.primary,
  },
  segButtonPressed: {
    opacity: 0.85,
  },
  segButtonText: {
    ...Typography.caption,
    color: Colors.light.text,
  },
  segButtonTextSelected: {
    color: Colors.light.buttonText,
  },
  menuItem: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: Spacing.sm,
  },
  menuItemPressed: {
    opacity: 0.7,
  },
  menuItemText: {
    ...Typography.body,
    color: Colors.light.text,
    flex: 1,
    marginLeft: Spacing.md,
  },
  menuItemDescription: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    marginTop: Spacing.xs,
  },
  warningText: {
    color: "#E67E22",
  },
  dangerText: {
    color: "#E74C3C",
  },
  version: {
    ...Typography.caption,
    color: Colors.light.textSecondary,
    textAlign: "center",
    marginTop: Spacing.lg,
  },
});
-e 
========== FILE: ./client/components/KeyboardAwareScrollViewCompat.tsx ==========
import { Platform, ScrollView, ScrollViewProps } from "react-native";
import {
  KeyboardAwareScrollView,
  KeyboardAwareScrollViewProps,
} from "react-native-keyboard-controller";

type Props = KeyboardAwareScrollViewProps & ScrollViewProps;

/**
 * KeyboardAwareScrollView that falls back to ScrollView on web.
 * Use this for any screen containing text inputs.
 */
export function KeyboardAwareScrollViewCompat({
  children,
  keyboardShouldPersistTaps = "handled",
  ...props
}: Props) {
  if (Platform.OS === "web") {
    return (
      <ScrollView
        keyboardShouldPersistTaps={keyboardShouldPersistTaps}
        {...props}
      >
        {children}
      </ScrollView>
    );
  }

  return (
    <KeyboardAwareScrollView
      keyboardShouldPersistTaps={keyboardShouldPersistTaps}
      {...props}
    >
      {children}
    </KeyboardAwareScrollView>
  );
}
-e 
========== FILE: ./client/components/ThemedView.tsx ==========
import { View, type ViewProps } from "react-native";

import { useTheme } from "@/hooks/useTheme";

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({
  style,
  lightColor,
  darkColor,
  ...otherProps
}: ThemedViewProps) {
  const { theme, isDark } = useTheme();

  const backgroundColor =
    isDark && darkColor
      ? darkColor
      : !isDark && lightColor
        ? lightColor
        : theme.backgroundRoot;

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
-e 
========== FILE: ./client/components/ErrorBoundary.tsx ==========
import React, { Component, ComponentType, PropsWithChildren } from "react";
import { ErrorFallback, ErrorFallbackProps } from "@/components/ErrorFallback";

export type ErrorBoundaryProps = PropsWithChildren<{
  FallbackComponent?: ComponentType<ErrorFallbackProps>;
  onError?: (error: Error, stackTrace: string) => void;
}>;

type ErrorBoundaryState = { error: Error | null };

/**
 * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.
 * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
 */

export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  state: ErrorBoundaryState = { error: null };

  static defaultProps: {
    FallbackComponent: ComponentType<ErrorFallbackProps>;
  } = {
    FallbackComponent: ErrorFallback,
  };

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { error };
  }

  componentDidCatch(error: Error, info: { componentStack: string }): void {
    if (typeof this.props.onError === "function") {
      this.props.onError(error, info.componentStack);
    }
  }

  resetError = (): void => {
    this.setState({ error: null });
  };

  render() {
    const { FallbackComponent } = this.props;

    return this.state.error && FallbackComponent ? (
      <FallbackComponent
        error={this.state.error}
        resetError={this.resetError}
      />
    ) : (
      this.props.children
    );
  }
}
-e 
========== FILE: ./client/components/HeaderTitle.tsx ==========
import React from "react";
import { View, StyleSheet, Image } from "react-native";

import { ThemedText } from "@/components/ThemedText";
import { Spacing } from "@/constants/theme";

interface HeaderTitleProps {
  title: string;
}

export function HeaderTitle({ title }: HeaderTitleProps) {
  return (
    <View style={styles.container}>
      <Image
        source={require("../../assets/images/icon.png")}
        style={styles.icon}
        resizeMode="contain"
      />
      <ThemedText style={styles.title}>{title}</ThemedText>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-start",
  },
  icon: {
    width: 28,
    height: 28,
    marginRight: Spacing.sm,
  },
  title: {
    fontSize: 17,
    fontWeight: "600",
  },
});
-e 
========== FILE: ./client/components/Spacer.tsx ==========
import { View } from "react-native";

type Props = {
  width?: number;
  height?: number;
};

export default function Spacer(props: Props) {
  const width: number = props.width ?? 1;
  const height: number = props.height ?? 1;

  return (
    <View
      style={{
        width,
        height,
      }}
    />
  );
}
-e 
========== FILE: ./client/components/ThemedText.tsx ==========
import { Text, type TextProps } from "react-native";

import { useTheme } from "@/hooks/useTheme";
import { Typography } from "@/constants/theme";

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: "h1" | "h2" | "h3" | "h4" | "body" | "small" | "link";
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = "body",
  ...rest
}: ThemedTextProps) {
  const { theme, isDark } = useTheme();

  const getColor = () => {
    if (isDark && darkColor) {
      return darkColor;
    }

    if (!isDark && lightColor) {
      return lightColor;
    }

    if (type === "link") {
      return theme.link;
    }

    return theme.text;
  };

  const getTypeStyle = () => {
    switch (type) {
      case "h1":
        return Typography.h1;
      case "h2":
        return Typography.h2;
      case "h3":
        return Typography.h3;
      case "h4":
        return Typography.h4;
      case "body":
        return Typography.body;
      case "small":
        return Typography.small;
      case "link":
        return Typography.link;
      default:
        return Typography.body;
    }
  };

  return (
    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />
  );
}
-e 
========== FILE: ./client/components/Button.tsx ==========
import React, { ReactNode } from "react";
import { StyleSheet, Pressable, ViewStyle, StyleProp } from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  WithSpringConfig,
} from "react-native-reanimated";

import { ThemedText } from "@/components/ThemedText";
import { useTheme } from "@/hooks/useTheme";
import { BorderRadius, Spacing } from "@/constants/theme";

interface ButtonProps {
  onPress?: () => void;
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
  disabled?: boolean;
}

const springConfig: WithSpringConfig = {
  damping: 15,
  mass: 0.3,
  stiffness: 150,
  overshootClamping: true,
  energyThreshold: 0.001,
};

const AnimatedPressable = Animated.createAnimatedComponent(Pressable);

export function Button({
  onPress,
  children,
  style,
  disabled = false,
}: ButtonProps) {
  const { theme } = useTheme();
  const scale = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const handlePressIn = () => {
    if (!disabled) {
      scale.value = withSpring(0.98, springConfig);
    }
  };

  const handlePressOut = () => {
    if (!disabled) {
      scale.value = withSpring(1, springConfig);
    }
  };

  return (
    <AnimatedPressable
      onPress={disabled ? undefined : onPress}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      disabled={disabled}
      style={[
        styles.button,
        {
          backgroundColor: theme.link,
          opacity: disabled ? 0.5 : 1,
        },
        style,
        animatedStyle,
      ]}
    >
      <ThemedText
        type="body"
        style={[styles.buttonText, { color: theme.buttonText }]}
      >
        {children}
      </ThemedText>
    </AnimatedPressable>
  );
}

const styles = StyleSheet.create({
  button: {
    height: Spacing.buttonHeight,
    borderRadius: BorderRadius.full,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    fontWeight: "600",
  },
});
-e 
========== FILE: ./client/components/ErrorFallback.tsx ==========
import React, { useState } from "react";
import { reloadAppAsync } from "expo";
import {
  StyleSheet,
  View,
  Pressable,
  ScrollView,
  Text,
  Modal,
} from "react-native";
import { Feather } from "@expo/vector-icons";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { useTheme } from "@/hooks/useTheme";
import { Spacing, BorderRadius, Fonts } from "@/constants/theme";

export type ErrorFallbackProps = {
  error: Error;
  resetError: () => void;
};

export function ErrorFallback({ error, resetError }: ErrorFallbackProps) {
  const { theme } = useTheme();
  const [isModalVisible, setIsModalVisible] = useState(false);

  const handleRestart = async () => {
    try {
      await reloadAppAsync();
    } catch (restartError) {
      console.error("Failed to restart app:", restartError);
      resetError();
    }
  };

  const formatErrorDetails = (): string => {
    let details = `Error: ${error.message}\n\n`;
    if (error.stack) {
      details += `Stack Trace:\n${error.stack}`;
    }
    return details;
  };

  return (
    <ThemedView style={styles.container}>
      {__DEV__ ? (
        <Pressable
          onPress={() => setIsModalVisible(true)}
          style={({ pressed }) => [
            styles.topButton,
            {
              backgroundColor: theme.backgroundDefault,
              opacity: pressed ? 0.8 : 1,
            },
          ]}
        >
          <Feather name="alert-circle" size={20} color={theme.text} />
        </Pressable>
      ) : null}

      <View style={styles.content}>
        <ThemedText type="h1" style={styles.title}>
          Something went wrong
        </ThemedText>

        <ThemedText type="body" style={styles.message}>
          Please reload the app to continue.
        </ThemedText>

        <Pressable
          onPress={handleRestart}
          style={({ pressed }) => [
            styles.button,
            {
              backgroundColor: theme.link,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.98 : 1 }],
            },
          ]}
        >
          <ThemedText
            type="body"
            style={[styles.buttonText, { color: theme.buttonText }]}
          >
            Try Again
          </ThemedText>
        </Pressable>
      </View>

      {__DEV__ ? (
        <Modal
          visible={isModalVisible}
          animationType="slide"
          transparent={true}
          onRequestClose={() => setIsModalVisible(false)}
        >
          <View style={styles.modalOverlay}>
            <ThemedView style={styles.modalContainer}>
              <View style={styles.modalHeader}>
                <ThemedText type="h2" style={styles.modalTitle}>
                  Error Details
                </ThemedText>
                <Pressable
                  onPress={() => setIsModalVisible(false)}
                  style={({ pressed }) => [
                    styles.closeButton,
                    { opacity: pressed ? 0.6 : 1 },
                  ]}
                >
                  <Feather name="x" size={24} color={theme.text} />
                </Pressable>
              </View>

              <ScrollView
                style={styles.modalScrollView}
                contentContainerStyle={styles.modalScrollContent}
                showsVerticalScrollIndicator
              >
                <View
                  style={[
                    styles.errorContainer,
                    { backgroundColor: theme.backgroundDefault },
                  ]}
                >
                  <Text
                    style={[
                      styles.errorText,
                      {
                        color: theme.text,
                        fontFamily: Fonts?.mono || "monospace",
                      },
                    ]}
                    selectable
                  >
                    {formatErrorDetails()}
                  </Text>
                </View>
              </ScrollView>
            </ThemedView>
          </View>
        </Modal>
      ) : null}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: "100%",
    height: "100%",
    justifyContent: "center",
    alignItems: "center",
    padding: Spacing["2xl"],
  },
  content: {
    alignItems: "center",
    justifyContent: "center",
    gap: Spacing.lg,
    width: "100%",
    maxWidth: 600,
  },
  title: {
    textAlign: "center",
    lineHeight: 40,
  },
  message: {
    textAlign: "center",
    opacity: 0.7,
    lineHeight: 24,
  },
  topButton: {
    position: "absolute",
    top: Spacing["2xl"] + Spacing.lg,
    right: Spacing.lg,
    width: 44,
    height: 44,
    borderRadius: BorderRadius.md,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    zIndex: 10,
  },
  button: {
    paddingVertical: Spacing.lg,
    borderRadius: BorderRadius.md,
    paddingHorizontal: Spacing["2xl"],
    minWidth: 200,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  buttonText: {
    fontWeight: "600",
    textAlign: "center",
    fontSize: 16,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "flex-end",
  },
  modalContainer: {
    width: "100%",
    height: "90%",
    borderTopLeftRadius: BorderRadius.lg,
    borderTopRightRadius: BorderRadius.lg,
  },
  modalHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: Spacing.lg,
    paddingTop: Spacing.lg,
    paddingBottom: Spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: "rgba(128, 128, 128, 0.2)",
  },
  modalTitle: {
    fontWeight: "600",
  },
  closeButton: {
    padding: Spacing.xs,
  },
  modalScrollView: {
    flex: 1,
  },
  modalScrollContent: {
    padding: Spacing.lg,
  },
  errorContainer: {
    width: "100%",
    borderRadius: BorderRadius.md,
    overflow: "hidden",
    padding: Spacing.lg,
  },
  errorText: {
    fontSize: 12,
    lineHeight: 18,
    width: "100%",
  },
});
-e 
========== FILE: ./client/components/Card.tsx ==========
import React from "react";
import { StyleSheet, Pressable, ViewStyle } from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  WithSpringConfig,
} from "react-native-reanimated";

import { ThemedText } from "@/components/ThemedText";
import { Colors, Spacing, BorderRadius, Shadows } from "@/constants/theme";

interface CardProps {
  elevation?: number;
  title?: string;
  description?: string;
  children?: React.ReactNode;
  onPress?: () => void;
  style?: ViewStyle;
}

const springConfig: WithSpringConfig = {
  damping: 15,
  mass: 0.3,
  stiffness: 150,
  overshootClamping: true,
  energyThreshold: 0.001,
};

const AnimatedPressable = Animated.createAnimatedComponent(Pressable);

export function Card({
  title,
  description,
  children,
  onPress,
  style,
}: CardProps) {
  const scale = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const handlePressIn = () => {
    if (onPress) {
      scale.value = withSpring(0.98, springConfig);
    }
  };

  const handlePressOut = () => {
    if (onPress) {
      scale.value = withSpring(1, springConfig);
    }
  };

  return (
    <AnimatedPressable
      onPress={onPress}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      disabled={!onPress}
      style={[
        styles.card,
        animatedStyle,
        style,
      ]}
    >
      {title ? (
        <ThemedText type="h4" style={styles.cardTitle}>
          {title}
        </ThemedText>
      ) : null}
      {description ? (
        <ThemedText type="small" style={styles.cardDescription}>
          {description}
        </ThemedText>
      ) : null}
      {children}
    </AnimatedPressable>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: Colors.light.surface,
    padding: Spacing.lg,
    borderRadius: BorderRadius.sm,
    ...Shadows.card,
  },
  cardTitle: {
    marginBottom: Spacing.sm,
  },
  cardDescription: {
    opacity: 0.7,
  },
});
-e 
========== FILE: ./client/components/BackButton.tsx ==========
import React from "react";
import { Pressable, Platform } from "react-native";
import { AntDesign } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import * as Haptics from "expo-haptics";
import { Colors } from "@/constants/theme";

interface BackButtonProps {
  onPress?: () => void;
}

export function BackButton({ onPress }: BackButtonProps) {
  const navigation = useNavigation();

  const handlePress = async () => {
    if (Platform.OS !== "web") {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    if (onPress) {
      onPress();
    } else {
      navigation.goBack();
    }
  };

  return (
    <Pressable
      onPress={handlePress}
      style={({ pressed }) => ({
        opacity: pressed ? 0.7 : 1,
        padding: 8,
      })}
      testID="back-button"
    >
      <AntDesign name="left" size={24} color={Colors.light.text} />
    </Pressable>
  );
}
-e 
========== FILE: ./client/components/DragonflyFlight.tsx ==========
import React, { useEffect, useMemo, useRef, useState } from "react";
import { Animated, Dimensions, StyleSheet, ViewStyle } from "react-native";

type Variant = "blue" | "white";
type Phase = "idle" | "settle" | "peak" | "cool";
type Pose = "hover" | "glide" | "dart" | "fly_up" | "fly_down" | "top_down";

const SPRITES: Record<Variant, Partial<Record<Pose, any>>> = {
  blue: {
    hover: require("../../assets/images/dragonfly-blue-hover.png"),
    glide: require("../../assets/images/dragonfly-blue-glide.png"),
    dart: require("../../assets/images/dragonfly-blue-dart.png"),
    fly_down: require("../../assets/images/dragonfly-blue-fly_down.png"),
    top_down: require("../../assets/images/dragonfly-blue-top_down.png"),
  },
  white: {
    hover: require("../../assets/images/dragonfly-white-hover.png"),
    glide: require("../../assets/images/dragonfly-white-glide.png"),
    dart: require("../../assets/images/dragonfly-white-dart.png"),
    fly_up: require("../../assets/images/dragonfly-white-fly_up.png"),
    fly_down: require("../../assets/images/dragonfly-white-fly_down.png"),
    top_down: require("../../assets/images/dragonfly-white-top_down.png"),
  },
};

function clamp(n: number, lo: number, hi: number) {
  return Math.max(lo, Math.min(hi, n));
}

export type DragonflyFlightProps = {
  variant: Variant;
  phase: Phase;
  intensity: number; // 0..1
  carrierDensity: number; // arbitrary density proxy
  musicPositionMs?: number;
  style?: ViewStyle;
};

export function DragonflyFlight({
  variant,
  phase,
  intensity,
  carrierDensity,
  musicPositionMs,
  style,
}: DragonflyFlightProps) {
  const { width: W, height: H } = Dimensions.get("window");

  const x = useRef(new Animated.Value(-120)).current;
  const y = useRef(new Animated.Value(H * 0.22)).current;
  const scale = useRef(new Animated.Value(1)).current;
  const rotate = useRef(new Animated.Value(0)).current;

  const [dir, setDir] = useState<1 | -1>(1);
  const [pose, setPose] = useState<Pose>("hover");

  const startMsRef = useRef<number>(Date.now());
  const beatBpm = 80;
  const beatPeriodMs = 60000 / beatBpm;

  const visualBeatHz = useMemo(() => {
    // carrierDensity -> a human-visible beat rate (clamped)
    return clamp(carrierDensity * 0.08, 0.8, 3.2);
  }, [carrierDensity]);

  const jitterHz = useMemo(
    () => clamp(carrierDensity * 0.25, 2, 10),
    [carrierDensity],
  );
  const baseScale = useMemo(
    () => 0.95 + 0.25 * clamp(intensity, 0, 1),
    [intensity],
  );

  // Cross-screen travel. Flip direction when finished; effect re-runs on dir change.
  useEffect(() => {
    let cancelled = false;

    const travel = W + 260;
    const startX = dir === 1 ? -140 : travel - 140;
    const endX = dir === 1 ? travel - 140 : -140;

    x.setValue(startX);

    const baseMs = phase === "peak" ? 2600 : phase === "settle" ? 4200 : 5200;
    const ms = clamp(baseMs - intensity * 1400, 1800, 6500);

    const anim = Animated.timing(x, {
      toValue: endX,
      duration: ms,
      useNativeDriver: true,
    });

    anim.start(({ finished }) => {
      if (!finished || cancelled) return;
      setDir((d) => (d === 1 ? -1 : 1));
    });

    return () => {
      cancelled = true;
      x.stopAnimation();
    };
  }, [W, dir, phase, intensity, x]);

  // Pose selection locked to beat index
  useEffect(() => {
    const id = setInterval(() => {
      const nowMs = Date.now();
      const posMs = musicPositionMs ?? nowMs - startMsRef.current;
      const beatIndex = Math.floor(posMs / beatPeriodMs);

      if (phase === "peak") {
        if (beatIndex % 5 === 0) setPose("top_down");
        else if (beatIndex % 2 === 0) setPose("dart");
        else setPose("fly_down");
      } else if (phase === "settle") {
        setPose(beatIndex % 3 === 0 ? "glide" : "hover");
      } else {
        setPose("hover");
      }
    }, 220);

    return () => clearInterval(id);
  }, [phase, musicPositionMs, beatPeriodMs]);

  // Beat-locked bobbing + density jitter (rAF loop, correctly cancellable)
  useEffect(() => {
    let mounted = true;
    const rafRef = { id: 0 };

    const tick = () => {
      if (!mounted) return;

      const nowMs = Date.now();
      const posMs = musicPositionMs ?? nowMs - startMsRef.current;
      const posS = posMs / 1000;
      const beatPhase = (posMs % beatPeriodMs) / beatPeriodMs;

      const twoPi = Math.PI * 2;

      const bobAmp = 10 + 26 * clamp(intensity, 0, 1);
      const bob = Math.sin(twoPi * beatPhase) * bobAmp;

      const jitterAmp = phase === "peak" ? 6 : 3.5;
      const jitter = Math.sin(twoPi * posS * jitterHz) * jitterAmp;

      const drift =
        Math.sin(twoPi * posS * visualBeatHz * 0.25) * (6 + 10 * intensity);

      y.setValue(H * 0.22 + bob + jitter + drift);

      const s =
        baseScale *
        (1 +
          0.06 * Math.sin(twoPi * beatPhase) +
          0.03 * Math.sin(twoPi * posS * 1.7));
      scale.setValue(s);

      const tilt =
        (phase === "peak" ? 10 : 6) * Math.sin(twoPi * beatPhase + Math.PI / 4);
      rotate.setValue(tilt);

      rafRef.id = requestAnimationFrame(tick);
    };

    rafRef.id = requestAnimationFrame(tick);

    return () => {
      mounted = false;
      cancelAnimationFrame(rafRef.id);
    };
  }, [
    H,
    intensity,
    phase,
    musicPositionMs,
    beatPeriodMs,
    baseScale,
    jitterHz,
    visualBeatHz,
    y,
    scale,
    rotate,
  ]);

  const spriteSource = (SPRITES[variant][pose] ??
    SPRITES[variant].hover) as any;

  const transform = [
    { translateX: x },
    { translateY: y },
    { scale },
    {
      rotate: rotate.interpolate({
        inputRange: [-20, 20],
        outputRange: ["-20deg", "20deg"],
      }),
    },
    { scaleX: dir === 1 ? 1 : -1 },
  ];

  return (
    <Animated.Image
      source={spriteSource}
      style={[styles.img, style, { transform }]}
      resizeMode="contain"
    />
  );
}

const styles = StyleSheet.create({
  img: {
    position: "absolute",
    width: 220,
    height: 220,
    opacity: 0.95,
  },
});
-e 
========== FILE: ./client/services/SensoryEngine.ts ==========
import * as Haptics from 'expo-haptics';
import { Platform } from 'react-native';
import type { HapticPattern, PeakStyle } from '@/types';

type SessionPhase = 'idle' | 'settle' | 'peak' | 'cool' | 'complete';

class SensoryEngineService {
  private isVibrating = false;
  private vibrationInterval: ReturnType<typeof setTimeout> | null = null;
  private intensity: number = 0.5;
  private snapDensity: number = 0.5;
  private peakStyle: PeakStyle = 'max';
  private currentPhase: SessionPhase = 'idle';
  private currentPattern: HapticPattern = 'standard';
  private syncClock: number = 0;
  private lastHapticTime: number = 0;

  setIntensity(value: number) {
    this.intensity = Math.max(0, Math.min(1, value));
  }

  setSnapDensity(value: number) {
    this.snapDensity = Math.max(0.1, Math.min(1, value));
  }

  setPeakStyle(style: PeakStyle) {
    this.peakStyle = style;
  }

  updatePhase(phase: SessionPhase) {
    this.currentPhase = phase;
  }

  async playStartSound() {
    if (Platform.OS !== 'web') {
      try {
        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      } catch (e) {
        console.log('Start sound feedback not available');
      }
    }
  }

  async playCompleteSound() {
    if (Platform.OS !== 'web') {
      try {
        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        await new Promise(resolve => setTimeout(resolve, 200));
        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      } catch (e) {
        console.log('Complete sound feedback not available');
      }
    }
  }

  async triggerHaptic(type: 'light' | 'medium' | 'heavy' | 'success' | 'warning' | 'error') {
    if (Platform.OS === 'web') return;

    try {
      switch (type) {
        case 'light':
          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          break;
        case 'medium':
          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
          break;
        case 'heavy':
          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
          break;
        case 'success':
          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          break;
        case 'warning':
          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
          break;
        case 'error':
          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
          break;
      }
    } catch (error) {
      console.log('Haptics not available');
    }
  }

  async startPattern(pattern: HapticPattern, phase?: SessionPhase) {
    if (Platform.OS === 'web') return;
    
    this.stopPattern();
    this.isVibrating = true;
    this.currentPattern = pattern;
    this.currentPhase = phase || 'settle';
    this.syncClock = Date.now();

    this.runSynchronizedPattern();
  }

  private async runSynchronizedPattern() {
    if (!this.isVibrating) return;

    const now = Date.now();
    const elapsed = now - this.syncClock;
    
    const phaseMultiplier = this.getPhaseMultiplier();
    const densityMultiplier = 0.5 + this.snapDensity * 0.5;
    
    const baseInterval = this.getBaseInterval();
    const adjustedInterval = baseInterval / (phaseMultiplier * densityMultiplier);

    if (now - this.lastHapticTime >= adjustedInterval) {
      await this.executeHapticForPhase();
      this.lastHapticTime = now;
    }

    this.vibrationInterval = setTimeout(() => this.runSynchronizedPattern(), 16);
  }

  private getPhaseMultiplier(): number {
    switch (this.currentPhase) {
      case 'settle':
        return 0.7;
      case 'peak':
        return this.peakStyle === 'max' ? 1.5 : 1.2;
      case 'cool':
        return 0.5;
      default:
        return 0.6;
    }
  }

  private getBaseInterval(): number {
    switch (this.currentPattern) {
      case 'standard':
        return 800 - (this.intensity * 400);
      case 'gentle-wave':
        return 1000 - (this.intensity * 300);
      case 'soft-pulse':
        return 1200 - (this.intensity * 400);
      default:
        return 800;
    }
  }

  private async executeHapticForPhase() {
    if (!this.isVibrating || Platform.OS === 'web') return;

    try {
      switch (this.currentPhase) {
        case 'settle':
          await this.executeSettleHaptic();
          break;
        case 'peak':
          await this.executePeakHaptic();
          break;
        case 'cool':
          await this.executeCoolHaptic();
          break;
        default:
          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      }
    } catch (error) {
      console.log('Haptic execution failed');
    }
  }

  private async executeSettleHaptic() {
    const style = this.intensity > 0.7 
      ? Haptics.ImpactFeedbackStyle.Medium 
      : Haptics.ImpactFeedbackStyle.Light;
    
    await Haptics.impactAsync(style);
    
    if (this.currentPattern === 'gentle-wave') {
      await this.delay(80);
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  }

  private async executePeakHaptic() {
    if (this.peakStyle === 'max') {
      const style = this.intensity > 0.5 
        ? Haptics.ImpactFeedbackStyle.Heavy 
        : Haptics.ImpactFeedbackStyle.Medium;
      
      await Haptics.impactAsync(style);
      
      if (this.snapDensity > 0.6) {
        await this.delay(50);
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      }
    } else {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      await this.delay(40);
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      
      if (this.snapDensity > 0.7) {
        await this.delay(60);
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      }
    }
  }

  private async executeCoolHaptic() {
    const style = Haptics.ImpactFeedbackStyle.Light;
    await Haptics.impactAsync(style);
    
    if (this.currentPattern === 'soft-pulse') {
      await this.delay(100);
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  stopPattern() {
    this.isVibrating = false;
    if (this.vibrationInterval) {
      clearTimeout(this.vibrationInterval);
      this.vibrationInterval = null;
    }
    this.currentPhase = 'idle';
  }

  async cleanup() {
    this.stopPattern();
  }

  getSyncInfo() {
    return {
      isVibrating: this.isVibrating,
      currentPhase: this.currentPhase,
      currentPattern: this.currentPattern,
      intensity: this.intensity,
      snapDensity: this.snapDensity,
      peakStyle: this.peakStyle,
      elapsedMs: Date.now() - this.syncClock,
    };
  }
}

export const SensoryEngine = new SensoryEngineService();
-e 
========== FILE: ./client/services/HapticsService.ts ==========
import * as Haptics from 'expo-haptics';
import { Platform } from 'react-native';
import type { HapticPattern, PeakStyle } from '@/types';

type SessionPhase = 'idle' | 'settle' | 'peak' | 'cool' | 'complete';

const MAX_HAPTIC_DURATION_MS = 30000;
const SNAP_MIN_HZ = 2;
const SNAP_MAX_HZ = 8;

class HapticsServiceClass {
  private isActive = false;
  private hapticLoop: ReturnType<typeof setTimeout> | null = null;
  private intensity: number = 0.5;
  private snapDensity: number = 0.5;
  private peakStyle: PeakStyle = 'max';
  private currentPhase: SessionPhase = 'idle';
  private currentPattern: HapticPattern = 'standard';
  private sessionStartTime: number = 0;
  private phaseStartTime: number = 0;
  private audioSyncCallback: (() => number) | null = null;

  setIntensity(value: number) {
    this.intensity = Math.max(0.1, Math.min(1, value));
  }

  setSnapDensity(value: number) {
    this.snapDensity = Math.max(0, Math.min(1, value));
  }

  setPeakStyle(style: PeakStyle) {
    this.peakStyle = style;
  }

  setAudioSyncCallback(callback: () => number) {
    this.audioSyncCallback = callback;
  }

  updatePhase(phase: SessionPhase) {
    if (phase !== this.currentPhase) {
      this.currentPhase = phase;
      this.phaseStartTime = Date.now();
    }
  }

  async playStartFeedback() {
    if (Platform.OS === 'web') return;
    try {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (e) {}
  }

  async playCompleteFeedback() {
    if (Platform.OS === 'web') return;
    try {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      await this.delay(150);
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (e) {}
  }

  async start(pattern: HapticPattern, initialPhase: SessionPhase = 'settle') {
    if (Platform.OS === 'web') return;
    
    this.stop();
    this.isActive = true;
    this.currentPattern = pattern;
    this.currentPhase = initialPhase;
    this.sessionStartTime = Date.now();
    this.phaseStartTime = Date.now();
    
    this.runHapticLoop();
  }

  private async runHapticLoop() {
    if (!this.isActive) return;
    
    const elapsed = Date.now() - this.sessionStartTime;
    if (elapsed >= MAX_HAPTIC_DURATION_MS) {
      this.stop();
      return;
    }
    
    const interval = this.calculateInterval();
    await this.executeHaptic();
    
    this.hapticLoop = setTimeout(() => this.runHapticLoop(), interval);
  }

  private calculateInterval(): number {
    const phaseElapsed = Date.now() - this.phaseStartTime;
    
    switch (this.currentPhase) {
      case 'settle':
        return this.getSettleInterval();
      case 'peak':
        return this.getPeakInterval();
      case 'cool':
        return this.getCoolInterval();
      default:
        return 1000;
    }
  }

  private getSettleInterval(): number {
    const baseInterval = 600;
    const intensityFactor = 1 - (this.intensity * 0.4);
    return Math.round(baseInterval * intensityFactor);
  }

  private getPeakInterval(): number {
    if (this.peakStyle === 'max') {
      const baseHz = 10;
      return Math.round(1000 / baseHz);
    } else {
      const targetHz = SNAP_MIN_HZ + (this.snapDensity * (SNAP_MAX_HZ - SNAP_MIN_HZ));
      return Math.round(1000 / targetHz);
    }
  }

  private getCoolInterval(): number {
    const phaseElapsed = Date.now() - this.phaseStartTime;
    const baseInterval = 400;
    const slowdown = Math.min(phaseElapsed / 3000, 1) * 400;
    return Math.round(baseInterval + slowdown);
  }

  private async executeHaptic() {
    if (!this.isActive || Platform.OS === 'web') return;
    
    try {
      switch (this.currentPhase) {
        case 'settle':
          await this.executeSettleHaptic();
          break;
        case 'peak':
          await this.executePeakHaptic();
          break;
        case 'cool':
          await this.executeCoolHaptic();
          break;
      }
    } catch (e) {}
  }

  private async executeSettleHaptic() {
    const style = this.intensity > 0.6 
      ? Haptics.ImpactFeedbackStyle.Medium 
      : Haptics.ImpactFeedbackStyle.Light;
    
    await Haptics.impactAsync(style);
    
    if (this.currentPattern === 'gentle-wave') {
      await this.delay(60);
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  }

  private async executePeakHaptic() {
    if (this.peakStyle === 'max') {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
      if (this.intensity > 0.7) {
        await this.delay(30);
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
      }
    } else {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
      if (this.snapDensity > 0.5) {
        await this.delay(40);
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      }
    }
  }

  private async executeCoolHaptic() {
    const phaseElapsed = Date.now() - this.phaseStartTime;
    const fade = Math.max(0, 1 - phaseElapsed / 6000);
    
    if (fade > 0.5) {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    } else if (fade > 0.2) {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    } else {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  stop() {
    this.isActive = false;
    if (this.hapticLoop) {
      clearTimeout(this.hapticLoop);
      this.hapticLoop = null;
    }
    this.currentPhase = 'idle';
  }

  cleanup() {
    this.stop();
    this.audioSyncCallback = null;
  }

  getDebugInfo() {
    return {
      isActive: this.isActive,
      currentPhase: this.currentPhase,
      currentPattern: this.currentPattern,
      intensity: this.intensity,
      snapDensity: this.snapDensity,
      peakStyle: this.peakStyle,
      elapsedMs: Date.now() - this.sessionStartTime,
      phaseElapsedMs: Date.now() - this.phaseStartTime,
    };
  }
}

export const HapticsService = new HapticsServiceClass();
-e 
========== FILE: ./client/services/engines/AudioEngine.ts ==========
export type AudioCommand =
  | { tMs: number; type: "lofi"; action: "start" | "stop"; gain01: number }
  | { tMs: number; type: "volume"; gain01: number };

export interface AudioEngine {
  init(): Promise<void>;
  setMasterVolume(v01: number): Promise<void>;
  schedule(commands: AudioCommand[]): Promise<void>;
  stopAll(): Promise<void>;
}
-e 
========== FILE: ./client/services/engines/HapticsEngine.ts ==========
export type HapticCommand =
  | { tMs: number; type: "impact"; style: "light" | "medium" | "heavy" }
  | { tMs: number; type: "pause"; durationMs: number };

export interface HapticsEngine {
  init(): Promise<void>;
  setIntensity(v01: number): void;     // global scaling
  schedule(commands: HapticCommand[]): Promise<void>;
  stopAll(): Promise<void>;
}
-e 
========== FILE: ./client/services/engines/ExpoAudioEngine.ts ==========
-e 
========== FILE: ./client/services/engines/CoreHapticsEngine.ts ==========
// client/services/engines/CoreHapticsEngine.ts
export class CoreHapticsEngine {
  async init() {
    // This will be replaced by native module later
    throw new Error("CoreHapticsEngine not implemented (native module required).");
  }
  setIntensity(_v: number) {}
  async stopAll() {}
  async dispose() {}
}
-e 
========== FILE: ./client/services/engines/ExpoHapticsEngine.ts ==========
import * as Haptics from "expo-haptics";
import type { HapticPattern } from "@/types";

export type PeakStyle = "max" | "snap";

export type SensorySettings = {
  useAdvancedHaptics: boolean;
  hapticsIntensity01: number;
  peakStyle: PeakStyle;
  snapDensity01: number;
  audioVolume01: number;
};

type Phase = "settle" | "peak" | "coolDown";

const clamp01 = (v: number) => Math.max(0, Math.min(1, v));
const lerp = (a: number, b: number, t: number) => a + (b - a) * t;

export class ExpoHapticsEngine {
  private running = false;
  private runId = 0;

  private pattern: HapticPattern = "standard";
  private phase: Phase = "settle";
  private settings: SensorySettings = {
    useAdvancedHaptics: false,
    hapticsIntensity01: 0.85,
    peakStyle: "max",
    snapDensity01: 0.5,
    audioVolume01: 0.6,
  };

  private bedTimeout: ReturnType<typeof setTimeout> | null = null;
  private envTimeout: ReturnType<typeof setTimeout> | null = null;

  async init() {
    return;
  }

  setIntensity(level01: number) {
    this.settings.hapticsIntensity01 = clamp01(level01);
  }

  async start(pattern: HapticPattern, phase: Phase, settings: SensorySettings) {
    this.pattern = pattern;
    this.phase = phase;
    this.settings = { ...this.settings, ...settings };
    this.running = true;
    this.runId++;
    const myRun = this.runId;
    this.clearTimers();
    void this.loopBed(myRun);
    void this.loopEnvelope(myRun);
  }

  updatePhase(phase: Phase) {
    if (this.phase === phase) return;
    this.phase = phase;
    if (!this.running) return;
    this.runId++;
    const myRun = this.runId;
    this.clearTimers();
    void this.loopBed(myRun);
    void this.loopEnvelope(myRun);
  }

  async stopAll() {
    this.running = false;
    this.runId++;
    this.clearTimers();
  }

  async dispose() {
    await this.stopAll();
  }

  private clearTimers() {
    if (this.bedTimeout) clearTimeout(this.bedTimeout);
    if (this.envTimeout) clearTimeout(this.envTimeout);
    this.bedTimeout = null;
    this.envTimeout = null;
  }

  private baseBedIntervalMs(): number {
    switch (this.pattern) {
      case "gentle-wave":
        return 210;
      case "soft-pulse":
        return 185;
      case "standard":
      default:
        return 165;
    }
  }

  private phaseBedMultiplier(): number {
    if (this.phase === "peak") return 0.78;
    if (this.phase === "coolDown") return 1.15;
    return 1.0;
  }

  private intensityBedMultiplier(): number {
    const i = clamp01(this.settings.hapticsIntensity01);
    return lerp(1.22, 0.82, i);
  }

  private bedIntervalMs(): number {
    const ms =
      this.baseBedIntervalMs() *
      this.phaseBedMultiplier() *
      this.intensityBedMultiplier();
    return Math.max(85, Math.min(320, Math.round(ms)));
  }

  private burstGroupPauseMs(): number {
    const snap = clamp01(this.settings.snapDensity01);
    if (this.phase === "peak") return Math.round(lerp(420, 160, snap));
    if (this.phase === "coolDown") return Math.round(lerp(650, 380, snap));
    return Math.round(lerp(560, 280, snap));
  }

  private burstSnapsCount(): number {
    const snap = clamp01(this.settings.snapDensity01);
    return Math.round(lerp(2, 7, snap));
  }

  private chooseBedStyle(): Haptics.ImpactFeedbackStyle | "selection" {
    const i = clamp01(this.settings.hapticsIntensity01);
    if (this.phase === "coolDown")
      return i < 0.35 ? "selection" : Haptics.ImpactFeedbackStyle.Soft;
    if (this.phase === "settle") {
      if (i < 0.3) return "selection";
      if (i < 0.65) return Haptics.ImpactFeedbackStyle.Light;
      return Haptics.ImpactFeedbackStyle.Medium;
    }
    return Haptics.ImpactFeedbackStyle.Heavy;
  }

  private chooseBurstStyle(): Haptics.ImpactFeedbackStyle {
    const i = clamp01(this.settings.hapticsIntensity01);
    if (this.phase === "coolDown")
      return i > 0.6
        ? Haptics.ImpactFeedbackStyle.Medium
        : Haptics.ImpactFeedbackStyle.Soft;
    if (this.phase === "settle")
      return i > 0.7
        ? Haptics.ImpactFeedbackStyle.Medium
        : Haptics.ImpactFeedbackStyle.Light;
    if (this.settings.peakStyle === "max")
      return Haptics.ImpactFeedbackStyle.Heavy;
    return i > 0.7
      ? Haptics.ImpactFeedbackStyle.Rigid
      : Haptics.ImpactFeedbackStyle.Heavy;
  }

  private async loopBed(myRun: number) {
    if (!this.running || myRun !== this.runId) return;
    try {
      const style = this.chooseBedStyle();
      style === "selection"
        ? await Haptics.selectionAsync()
        : await Haptics.impactAsync(style);
    } catch {}
    if (!this.running || myRun !== this.runId) return;
    this.bedTimeout = setTimeout(
      () => void this.loopBed(myRun),
      this.bedIntervalMs(),
    );
  }

  private async loopEnvelope(myRun: number) {
    if (!this.running || myRun !== this.runId) return;
    try {
      if (this.phase === "peak" && this.settings.peakStyle === "snap") {
        const snaps = this.burstSnapsCount();
        const style = this.chooseBurstStyle();
        for (let k = 0; k < snaps; k++) {
          if (!this.running || myRun !== this.runId) return;
          await Haptics.impactAsync(style);
          await new Promise((r) => setTimeout(r, 55));
        }
      } else {
        const style = this.chooseBurstStyle();
        const count =
          this.phase === "peak" ? 4 : this.phase === "settle" ? 3 : 2;
        for (let k = 0; k < count; k++) {
          if (!this.running || myRun !== this.runId) return;
          await Haptics.impactAsync(style);
          await new Promise((r) => setTimeout(r, 60));
        }
      }
    } catch {}
    if (!this.running || myRun !== this.runId) return;
    this.envTimeout = setTimeout(
      () => void this.loopEnvelope(myRun),
      this.burstGroupPauseMs(),
    );
  }
}
-e 
========== FILE: ./client/services/Audio/ExpoAVAudioEngine.ts ==========
// client/services/audio/ExpoAVAudioEngine.ts
import { Audio } from "expo-av";

const clamp01 = (v: number) => Math.max(0, Math.min(1, v));

// IMPORTANT: adjust path if your assets folder differs
const ENTRAIN_LOOP = require("../../../assets/audio/entrain_loop.mp3");


export class ExpoAVAudioEngine {
  private loopSound: Audio.Sound | null = null;
  private initialized = false;
  private enabled = true;
  private volume01 = 0.6;

  async init() {
    if (this.initialized) return;

    await Audio.setAudioModeAsync({
      playsInSilentModeIOS: true,
      staysActiveInBackground: false,
      shouldDuckAndroid: true,
    });

    this.initialized = true;
  }

  setEnabled(enabled: boolean) {
    this.enabled = enabled;
    if (!enabled) {
      // fire and forget
      void this.stopAll();
    }
  }

  async setVolume(volume01: number) {
    this.volume01 = clamp01(volume01);
    if (this.loopSound) {
      await this.loopSound.setVolumeAsync(this.volume01);
    }
  }

  async startLoop() {
    if (!this.enabled) return;
    await this.init();

    if (this.loopSound) return;

    const { sound } = await Audio.Sound.createAsync(ENTRAIN_LOOP, {
      isLooping: true,
      volume: this.volume01,
    });

    this.loopSound = sound;
    await sound.playAsync();
  }

  async getPositionMs(): Promise<number> {
    if (!this.loopSound) return 0;
    const status = await this.loopSound.getStatusAsync();
    return status.isLoaded ? status.positionMillis : 0;
  }

  async stopAll() {
    if (!this.loopSound) return;
    try {
      await this.loopSound.stopAsync();
    } finally {
      await this.loopSound.unloadAsync();
      this.loopSound = null;
    }
  }

  async dispose() {
    await this.stopAll();
    this.initialized = false;
  }
}
-e 
========== FILE: ./client/services/StorageService.ts ==========
import AsyncStorage from "@react-native-async-storage/async-storage";
import type {
  SessionLog,
  UserPreferences,
  OnboardingState,
  AppState,
  SessionSite,
  SiteTuning,
} from "@/types";

const STORAGE_KEYS = {
  SESSIONS: "@alivio_sessions",
  PREFERENCES: "@alivio_preferences",
  ONBOARDING: "@alivio_onboarding",
};

const DEFAULT_PREFERENCES: UserPreferences = {
  displayName: "",
  hapticIntensity: 0.5,
  audioEnabled: true,
  audioVolume: 0.6,
  avatarId: "blue",
  dragonflyVariant: "blue",
  theme: "light",
  debugMode: false,
  peakStyle: "max",
  snapDensity: 0.5,
  selectedDuration: 24,
  siteTunings: {},
  discoveryCompleted: false,
  useAdvancedHaptics: false,
  peakStyle: "max",
  snapDensity01: 0.5,
  hapticsIntensity01: 0.85,
  audioVolume01: 0.6,
  debugEnabled: false,
};

const DEFAULT_ONBOARDING: OnboardingState = {
  completed: false,
  disclaimerAccepted: false,
  age: null,
  parentalConsentGiven: false,
};

class StorageServiceClass {
  async getSessions(): Promise<SessionLog[]> {
    try {
      const data = await AsyncStorage.getItem(STORAGE_KEYS.SESSIONS);
      return data ? JSON.parse(data) : [];
    } catch (error) {
      console.error("Error loading sessions:", error);
      return [];
    }
  }

  async saveSessions(sessions: SessionLog[]): Promise<void> {
    try {
      await AsyncStorage.setItem(
        STORAGE_KEYS.SESSIONS,
        JSON.stringify(sessions),
      );
    } catch (error) {
      console.error("Error saving sessions:", error);
    }
  }

  async addSession(session: SessionLog): Promise<void> {
    const sessions = await this.getSessions();
    sessions.unshift(session);
    await this.saveSessions(sessions);
  }

  async clearSessions(): Promise<void> {
    await this.saveSessions([]);
  }

  async getPreferences() {
    try {
      const raw = await AsyncStorage.getItem("alivio:preferences:v1");
      const stored = raw ? JSON.parse(raw) : null;
      return { ...DEFAULT_PREFERENCES, ...(stored ?? {}) };
    } catch {
      return { ...DEFAULT_PREFERENCES };
    }
  }


  async savePreferences(preferences: Partial<UserPreferences>): Promise<void> {
    try {
      const current = await this.getPreferences();
      const updated = { ...current, ...preferences };
      await AsyncStorage.setItem(
        STORAGE_KEYS.PREFERENCES,
        JSON.stringify(updated),
      );
    } catch (error) {
      console.error("Error saving preferences:", error);
    }
  }

  async getSiteTuning(site: SessionSite): Promise<SiteTuning | undefined> {
    const prefs = await this.getPreferences();
    return prefs.siteTunings[site];
  }

  async saveSiteTuning(site: SessionSite, tuning: SiteTuning): Promise<void> {
    const prefs = await this.getPreferences();
    const updatedTunings = { ...prefs.siteTunings, [site]: tuning };
    await this.savePreferences({ siteTunings: updatedTunings });
  }

  async getOnboarding(): Promise<OnboardingState> {
    try {
      const data = await AsyncStorage.getItem(STORAGE_KEYS.ONBOARDING);
      return data
        ? { ...DEFAULT_ONBOARDING, ...JSON.parse(data) }
        : DEFAULT_ONBOARDING;
    } catch (error) {
      console.error("Error loading onboarding:", error);
      return DEFAULT_ONBOARDING;
    }
  }

  async saveOnboarding(onboarding: Partial<OnboardingState>): Promise<void> {
    try {
      const current = await this.getOnboarding();
      const updated = { ...current, ...onboarding };
      await AsyncStorage.setItem(
        STORAGE_KEYS.ONBOARDING,
        JSON.stringify(updated),
      );
    } catch (error) {
      console.error("Error saving onboarding:", error);
    }
  }

  async completeOnboarding(): Promise<void> {
    await this.saveOnboarding({ completed: true });
  }

  async getAppState(): Promise<AppState> {
    const [onboarding, preferences, sessions] = await Promise.all([
      this.getOnboarding(),
      this.getPreferences(),
      this.getSessions(),
    ]);
    return { onboarding, preferences, sessions };
  }

  async resetApp(): Promise<void> {
    try {
      await AsyncStorage.multiRemove([
        STORAGE_KEYS.SESSIONS,
        STORAGE_KEYS.PREFERENCES,
        STORAGE_KEYS.ONBOARDING,
      ]);
    } catch (error) {
      console.error("Error resetting app:", error);
    }
  }

  async getSessionsThisWeek(): Promise<number> {
    const sessions = await this.getSessions();
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

    return sessions.filter((session) => {
      const sessionDate = new Date(session.date);
      return sessionDate >= oneWeekAgo;
    }).length;
  }
}

export const StorageService = new StorageServiceClass();
-e 
========== FILE: ./client/services/SensoryService.ts ==========
// client/services/SensoryService.ts
import type { HapticPattern } from "@/types";
import { ExpoAVAudioEngine } from "@/services/audio/ExpoAVAudioEngine";
import {
  ExpoHapticsEngine,
  SensorySettings,
} from "@/services/engines/ExpoHapticsEngine";

type Phase = "settle" | "peak" | "coolDown";

export class SensoryService {
  private audio = new ExpoAVAudioEngine();
  private haptics = new ExpoHapticsEngine();

  private initialized = false;
  private running = false;

  private lastPattern: HapticPattern = "standard";
  private lastSettings: SensorySettings = {
    useAdvancedHaptics: false,
    hapticsIntensity01: 0.85,
    peakStyle: "max",
    snapDensity01: 0.5,
    audioVolume01: 0.6,
  };

  async initIfNeeded() {
    if (this.initialized) return;
    await this.audio.init();
    await this.haptics.init();
    this.initialized = true;
  }

  async startSession(args: {
    pattern: HapticPattern;
    phase: "settle" | "peak" | "coolDown";
    audioEnabled: boolean;

    hapticsIntensity01: number;
    audioVolume01: number;

    peakStyle: "max" | "snap";
    snapDensity01: number;

    useAdvancedHaptics: boolean;
  }) {
    await this.initIfNeeded();

    const settings: SensorySettings = {
      useAdvancedHaptics: !!args.useAdvancedHaptics,
      hapticsIntensity01: args.hapticsIntensity01,
      peakStyle: args.peakStyle,
      snapDensity01: args.snapDensity01,
      audioVolume01: args.audioVolume01,
    };

    this.lastPattern = args.pattern;
    this.lastSettings = settings;

    // Audio
    this.audio.setEnabled(args.audioEnabled);
    await this.audio.setVolume(args.audioVolume01);
    if (args.audioEnabled) await this.audio.startLoop();
    else await this.audio.stopAll();

    // Haptics
    this.haptics.setIntensity(args.hapticsIntensity01);
    await this.haptics.start(args.pattern, args.phase, settings);

    this.running = true;
  }

  updatePhase(phase: Phase) {
    if (!this.running) return;
    this.haptics.updatePhase(phase);
  }

  async getMusicPositionMs(): Promise<number> {
    return this.audio.getPositionMs();
  }

  async stop() {
    this.running = false;
    await this.haptics.stopAll();
    await this.audio.stopAll();
  }

  async dispose() {
    await this.stop();
    await this.haptics.dispose();
    await this.audio.dispose();
    this.initialized = false;
  }
}

export const sensoryService = new SensoryService();
-e 
========== FILE: ./client/services/audio/ExpoAVAudioEngine.ts ==========
import { Audio, AVPlaybackStatus } from "expo-av";

export type SensoryProfile = 
  | "edge" 
  | "buffer" 
  | "deepwave" 
  | "rhythmiclayers";

export type TextureVariation = 
  | "constantflow" 
  | "rhythmicwaves" 
  | "adaptiveflow";

export type SessionDuration = 18 | 24 | 30;

export type TestProfile = 
  | "test_gate_control" 
  | "test_massage_simulation";

export interface AudioEngineConfig {
  masterVolume?: number;
  fadeInMs?: number;
  fadeOutMs?: number;
}

export interface PlaybackOptions {
  volume?: number;
  loop?: boolean;
  fadeIn?: boolean;
  fadeOut?: boolean;
}

const AUDIO_ASSETS: Record<string, any> = {
  "edge-constantflow-18s": require("@/../assets/audio/sensory-tracks/edge-constantflow-18s.wav"),
  "edge-constantflow-24s": require("@/../assets/audio/sensory-tracks/edge-constantflow-24s.wav"),
  "edge-constantflow-30s": require("@/../assets/audio/sensory-tracks/edge-constantflow-30s.wav"),
  "edge-rhythmicwaves-18s": require("@/../assets/audio/sensory-tracks/edge-rhythmicwaves-18s.wav"),
  "edge-rhythmicwaves-24s": require("@/../assets/audio/sensory-tracks/edge-rhythmicwaves-24s.wav"),
  "edge-rhythmicwaves-30s": require("@/../assets/audio/sensory-tracks/edge-rhythmicwaves-30s.wav"),
  "edge-adaptiveflow-18s": require("@/../assets/audio/sensory-tracks/edge-adaptiveflow-18s.wav"),
  "edge-adaptiveflow-24s": require("@/../assets/audio/sensory-tracks/edge-adaptiveflow-24s.wav"),
  "edge-adaptiveflow-30s": require("@/../assets/audio/sensory-tracks/edge-adaptiveflow-30s.wav"),
  "buffer-constantflow-18s": require("@/../assets/audio/sensory-tracks/buffer-constantflow-18s.wav"),
  "buffer-constantflow-24s": require("@/../assets/audio/sensory-tracks/buffer-constantflow-24s.wav"),
  "buffer-constantflow-30s": require("@/../assets/audio/sensory-tracks/buffer-constantflow-30s.wav"),
  "buffer-rhythmicwaves-18s": require("@/../assets/audio/sensory-tracks/buffer-rhythmicwaves-18s.wav"),
  "buffer-rhythmicwaves-24s": require("@/../assets/audio/sensory-tracks/buffer-rhythmicwaves-24s.wav"),
  "buffer-rhythmicwaves-30s": require("@/../assets/audio/sensory-tracks/buffer-rhythmicwaves-30s.wav"),
  "buffer-adaptiveflow-18s": require("@/../assets/audio/sensory-tracks/buffer-adaptiveflow-18s.wav"),
  "buffer-adaptiveflow-24s": require("@/../assets/audio/sensory-tracks/buffer-adaptiveflow-24s.wav"),
  "buffer-adaptiveflow-30s": require("@/../assets/audio/sensory-tracks/buffer-adaptiveflow-30s.wav"),
  "deepwave-constantflow-18s": require("@/../assets/audio/sensory-tracks/deepwave-constantflow-18s.wav"),
  "deepwave-constantflow-24s": require("@/../assets/audio/sensory-tracks/deepwave-constantflow-24s.wav"),
  "deepwave-constantflow-30s": require("@/../assets/audio/sensory-tracks/deepwave-constantflow-30s.wav"),
  "deepwave-rhythmicwaves-18s": require("@/../assets/audio/sensory-tracks/deepwave-rhythmicwaves-18s.wav"),
  "deepwave-rhythmicwaves-24s": require("@/../assets/audio/sensory-tracks/deepwave-rhythmicwaves-24s.wav"),
  "deepwave-rhythmicwaves-30s": require("@/../assets/audio/sensory-tracks/deepwave-rhythmicwaves-30s.wav"),
  "deepwave-adaptiveflow-18s": require("@/../assets/audio/sensory-tracks/deepwave-adaptiveflow-18s.wav"),
  "deepwave-adaptiveflow-24s": require("@/../assets/audio/sensory-tracks/deepwave-adaptiveflow-24s.wav"),
  "deepwave-adaptiveflow-30s": require("@/../assets/audio/sensory-tracks/deepwave-adaptiveflow-30s.wav"),
  "rhythmiclayers-constantflow-18s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-constantflow-18s.wav"),
  "rhythmiclayers-constantflow-24s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-constantflow-24s.wav"),
  "rhythmiclayers-constantflow-30s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-constantflow-30s.wav"),
  "rhythmiclayers-rhythmicwaves-18s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-rhythmicwaves-18s.wav"),
  "rhythmiclayers-rhythmicwaves-24s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-rhythmicwaves-24s.wav"),
  "rhythmiclayers-rhythmicwaves-30s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-rhythmicwaves-30s.wav"),
  "rhythmiclayers-adaptiveflow-18s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-adaptiveflow-18s.wav"),
  "rhythmiclayers-adaptiveflow-24s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-adaptiveflow-24s.wav"),
  "rhythmiclayers-adaptiveflow-30s": require("@/../assets/audio/sensory-tracks/rhythmiclayers-adaptiveflow-30s.wav"),
  "test_gate_control-18s": require("@/../assets/audio/test-profiles/test_gate_control-18s.wav"),
  "test_massage_simulation-30s": require("@/../assets/audio/test-profiles/test_massage_simulation-30s.wav"),
  "ui_start": require("@/../assets/audio/ui_start.mp3"),
  "ui_complete": require("@/../assets/audio/ui_complete.mp3"),
};

export class ExpoAVAudioEngine {
  private masterVolume: number = 0.7;
  private fadeInMs: number = 500;
  private fadeOutMs: number = 500;
  private currentSound: Audio.Sound | null = null;
  private uiSounds: Map<string, Audio.Sound> = new Map();
  private isInitialized: boolean = false;
  private fadeInterval: ReturnType<typeof setInterval> | null = null;

  constructor(config?: AudioEngineConfig) {
    if (config?.masterVolume !== undefined) {
      this.masterVolume = Math.max(0, Math.min(1, config.masterVolume));
    }
    if (config?.fadeInMs !== undefined) {
      this.fadeInMs = config.fadeInMs;
    }
    if (config?.fadeOutMs !== undefined) {
      this.fadeOutMs = config.fadeOutMs;
    }
  }

  async init(): Promise<void> {
    if (this.isInitialized) return;

    try {
      await Audio.setAudioModeAsync({
        playsInSilentModeIOS: true,
        allowsRecordingIOS: false,
        staysActiveInBackground: true,
        shouldDuckAndroid: true,
        playThroughEarpieceAndroid: false,
      });
      this.isInitialized = true;
    } catch (error) {
      console.warn("ExpoAVAudioEngine: Failed to initialize audio mode", error);
    }
  }

  async setMasterVolume(volume: number): Promise<void> {
    this.masterVolume = Math.max(0, Math.min(1, volume));
    if (this.currentSound) {
      await this.currentSound.setVolumeAsync(this.masterVolume);
    }
  }

  getMasterVolume(): number {
    return this.masterVolume;
  }

  private getTrackKey(
    profile: SensoryProfile,
    texture: TextureVariation,
    duration: SessionDuration
  ): string {
    return `${profile}-${texture}-${duration}s`;
  }

  private getTestTrackKey(profile: TestProfile): string {
    const durations: Record<TestProfile, number> = {
      test_gate_control: 18,
      test_massage_simulation: 30,
    };
    return `${profile}-${durations[profile]}s`;
  }

  async playSensoryTrack(
    profile: SensoryProfile,
    texture: TextureVariation,
    duration: SessionDuration,
    options?: PlaybackOptions
  ): Promise<void> {
    await this.init();
    await this.stopCurrentSound();

    const key = this.getTrackKey(profile, texture, duration);
    const asset = AUDIO_ASSETS[key];

    if (!asset) {
      console.warn(`ExpoAVAudioEngine: Track not found: ${key}`);
      return;
    }

    try {
      const volume = (options?.volume ?? 1) * this.masterVolume;
      const initialVolume = options?.fadeIn ? 0 : volume;

      const { sound } = await Audio.Sound.createAsync(asset, {
        shouldPlay: true,
        isLooping: options?.loop ?? false,
        volume: initialVolume,
      });

      this.currentSound = sound;

      if (options?.fadeIn) {
        await this.fadeIn(sound, volume, this.fadeInMs);
      }

      sound.setOnPlaybackStatusUpdate((status: AVPlaybackStatus) => {
        if (status.isLoaded && status.didJustFinish && !options?.loop) {
          this.handlePlaybackComplete();
        }
      });
    } catch (error) {
      console.warn(`ExpoAVAudioEngine: Failed to play track ${key}`, error);
    }
  }

  async playTestProfile(
    profile: TestProfile,
    options?: PlaybackOptions
  ): Promise<void> {
    await this.init();
    await this.stopCurrentSound();

    const key = this.getTestTrackKey(profile);
    const asset = AUDIO_ASSETS[key];

    if (!asset) {
      console.warn(`ExpoAVAudioEngine: Test profile not found: ${key}`);
      return;
    }

    try {
      const volume = (options?.volume ?? 1) * this.masterVolume;
      const initialVolume = options?.fadeIn ? 0 : volume;

      const { sound } = await Audio.Sound.createAsync(asset, {
        shouldPlay: true,
        isLooping: options?.loop ?? false,
        volume: initialVolume,
      });

      this.currentSound = sound;

      if (options?.fadeIn) {
        await this.fadeIn(sound, volume, this.fadeInMs);
      }

      sound.setOnPlaybackStatusUpdate((status: AVPlaybackStatus) => {
        if (status.isLoaded && status.didJustFinish && !options?.loop) {
          this.handlePlaybackComplete();
        }
      });
    } catch (error) {
      console.warn(`ExpoAVAudioEngine: Failed to play test profile ${key}`, error);
    }
  }

  async playUISound(soundId: "ui_start" | "ui_complete"): Promise<void> {
    await this.init();

    const asset = AUDIO_ASSETS[soundId];
    if (!asset) return;

    try {
      let sound = this.uiSounds.get(soundId);
      
      if (!sound) {
        const { sound: newSound } = await Audio.Sound.createAsync(asset, {
          shouldPlay: false,
          volume: this.masterVolume * 0.5,
        });
        sound = newSound;
        this.uiSounds.set(soundId, sound);
      }

      await sound.setPositionAsync(0);
      await sound.playAsync();
    } catch (error) {
      console.warn(`ExpoAVAudioEngine: Failed to play UI sound ${soundId}`, error);
    }
  }

  private async fadeIn(
    sound: Audio.Sound,
    targetVolume: number,
    durationMs: number
  ): Promise<void> {
    const steps = 20;
    const stepDuration = durationMs / steps;
    const volumeStep = targetVolume / steps;

    let currentStep = 0;

    return new Promise((resolve) => {
      this.fadeInterval = setInterval(async () => {
        currentStep++;
        const newVolume = Math.min(targetVolume, volumeStep * currentStep);
        
        try {
          await sound.setVolumeAsync(newVolume);
        } catch {}

        if (currentStep >= steps) {
          if (this.fadeInterval) clearInterval(this.fadeInterval);
          this.fadeInterval = null;
          resolve();
        }
      }, stepDuration);
    });
  }

  private async fadeOut(
    sound: Audio.Sound,
    durationMs: number
  ): Promise<void> {
    const status = await sound.getStatusAsync();
    if (!status.isLoaded) return;

    const startVolume = status.volume;
    const steps = 20;
    const stepDuration = durationMs / steps;
    const volumeStep = startVolume / steps;

    let currentStep = 0;

    return new Promise((resolve) => {
      this.fadeInterval = setInterval(async () => {
        currentStep++;
        const newVolume = Math.max(0, startVolume - volumeStep * currentStep);
        
        try {
          await sound.setVolumeAsync(newVolume);
        } catch {}

        if (currentStep >= steps) {
          if (this.fadeInterval) clearInterval(this.fadeInterval);
          this.fadeInterval = null;
          resolve();
        }
      }, stepDuration);
    });
  }

  async stopCurrentSound(fadeOut: boolean = true): Promise<void> {
    if (this.fadeInterval) {
      clearInterval(this.fadeInterval);
      this.fadeInterval = null;
    }

    if (this.currentSound) {
      try {
        if (fadeOut) {
          await this.fadeOut(this.currentSound, this.fadeOutMs);
        }
        await this.currentSound.stopAsync();
        await this.currentSound.unloadAsync();
      } catch {}
      this.currentSound = null;
    }
  }

  async pauseCurrentSound(): Promise<void> {
    if (this.currentSound) {
      try {
        await this.currentSound.pauseAsync();
      } catch {}
    }
  }

  async resumeCurrentSound(): Promise<void> {
    if (this.currentSound) {
      try {
        await this.currentSound.playAsync();
      } catch {}
    }
  }

  async getCurrentPosition(): Promise<number> {
    if (this.currentSound) {
      try {
        const status = await this.currentSound.getStatusAsync();
        if (status.isLoaded) {
          return status.positionMillis;
        }
      } catch {}
    }
    return 0;
  }

  async getDuration(): Promise<number> {
    if (this.currentSound) {
      try {
        const status = await this.currentSound.getStatusAsync();
        if (status.isLoaded && status.durationMillis) {
          return status.durationMillis;
        }
      } catch {}
    }
    return 0;
  }

  isPlaying(): boolean {
    return this.currentSound !== null;
  }

  private handlePlaybackComplete(): void {
    this.currentSound = null;
  }

  async dispose(): Promise<void> {
    await this.stopCurrentSound(false);

    for (const sound of this.uiSounds.values()) {
      try {
        await sound.unloadAsync();
      } catch {}
    }
    this.uiSounds.clear();
    this.isInitialized = false;
  }

  static getAvailableProfiles(): SensoryProfile[] {
    return ["edge", "buffer", "deepwave", "rhythmiclayers"];
  }

  static getAvailableTextures(): TextureVariation[] {
    return ["constantflow", "rhythmicwaves", "adaptiveflow"];
  }

  static getAvailableDurations(): SessionDuration[] {
    return [18, 24, 30];
  }

  static getAvailableTestProfiles(): TestProfile[] {
    return ["test_gate_control", "test_massage_simulation"];
  }

  static getProfileDisplayName(profile: SensoryProfile): string {
    const names: Record<SensoryProfile, string> = {
      edge: "Edge",
      buffer: "Buffer",
      deepwave: "Deep Wave",
      rhythmiclayers: "Rhythmic Layers",
    };
    return names[profile];
  }

  static getTextureDisplayName(texture: TextureVariation): string {
    const names: Record<TextureVariation, string> = {
      constantflow: "Constant Flow",
      rhythmicwaves: "Rhythmic Waves",
      adaptiveflow: "Adaptive Flow",
    };
    return names[texture];
  }

  static getTestProfileDisplayName(profile: TestProfile): string {
    const names: Record<TestProfile, string> = {
      test_gate_control: "Test A: Sharp Pain Relief",
      test_massage_simulation: "Test B: Deep Comfort",
    };
    return names[profile];
  }
}

export const audioEngine = new ExpoAVAudioEngine();
